<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>polyval&#39;s Wiki</title>
  
  <subtitle>知识不能碎片化，要结构化</subtitle>
  <link href="/Wiki/atom.xml" rel="self"/>
  
  <link href="http://polyval.github.io/Wiki/"/>
  <updated>2019-09-12T22:25:02.015Z</updated>
  <id>http://polyval.github.io/Wiki/</id>
  
  <author>
    <name>polyval</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://polyval.github.io/Wiki/wiki/Java/%E7%AC%94%E8%AE%B0/"/>
    <id>http://polyval.github.io/Wiki/wiki/Java/笔记/</id>
    <published>2019-03-31T01:53:20.667Z</published>
    <updated>2019-09-12T22:25:02.015Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><h2 id="搜索技巧"><a href="#搜索技巧" class="headerlink" title="搜索技巧"></a>搜索技巧</h2><p>末尾加上PDF，可以搜出一些高质量的文章，包括一些技术分享、大学的课件。</p><p>Wikipedia看参考文献，会有很多不错的资料。</p><p>关键字：Overview，Demystify</p><p>学习过程：从宏观上了解</p><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><h4 id="String-intern"><a href="#String-intern" class="headerlink" title="String.intern()"></a>String.intern()</h4><p>如果常量池中存在当前字符串, 就会直接返回当前字符串. 如果常量池中没有此字符串, 会将此字符串放入常量池中后, 再返回。常量池是堆中的一块特殊区域。</p><h3 id="hashCode-和equals"><a href="#hashCode-和equals" class="headerlink" title="hashCode()和equals()"></a>hashCode()和equals()</h3><h4 id="hashcode规约"><a href="#hashcode规约" class="headerlink" title="hashcode规约"></a>hashcode规约</h4><ul><li><p>对同一对象，hashcode方法返回值每次应相同</p><blockquote><p>如果不同，则会导致根据hashcode变化无法在桶中找到该元素。Python字典中要求key需要是immutable的也是这个原因</p></blockquote></li><li><p>如果重写了equals()方法，检查条件“两个对象使用equals()方法判断为相等，则hashCode()方法也应该相等”是否成立，如果不成立，则重写hashCode ()方法。</p></li><li><p>不要求不同对象返回不同hashcode，但是如果每个对象都可以返回不同的hashcode，可以提高hash table的性能。</p></li></ul><h4 id="重写equals时为什么要重写hashcode"><a href="#重写equals时为什么要重写hashcode" class="headerlink" title="重写equals时为什么要重写hashcode"></a>重写equals时为什么要重写hashcode</h4><p>不重写hashcode方法，涉及到HashMap、HashSet等依赖对象hashcode值的集合会出问题。</p><p>HashMap通过hashcode将对象放到对应的桶结构中，在取数据时，根据hashcode定位到桶，然后根据equal在桶中寻找到对象。</p><p>如果不重写hashcode，就可能出现两个相同的对象(业务上)，由于hashcode不同，而会在HashMap中存两份。</p><h3 id="synchronized关键字原理"><a href="#synchronized关键字原理" class="headerlink" title="synchronized关键字原理"></a>synchronized关键字原理</h3><p>synchronized通过monitor来实现线程同步，而monitor是通过mutex lock和condition variable来实现互斥，每个Java对象(包括类对象)都有个mutex lock。在synchronized包裹的代码前后会有monitorenter和moniterexit指令。Monitor中的互斥锁是OS层面来支持，在获取(monitor entry)和释放锁(monitor exit)存在大量的开销。因此HotSpot VM在这方面做了些<a href="https://pdfs.semanticscholar.org/edf9/54412a9b1ce955bea148199f325759779540.pdf?_ga=2.63410607.1434231496.1554627760-821097055.1554627760" rel="external nofollow noopener noreferrer" target="_blank">优化</a>，引入了轻量级锁和偏向锁等。</p><h4 id="monitor"><a href="#monitor" class="headerlink" title="monitor"></a>monitor</h4><p><a href="https://www.artima.com/insidejvm/ed2/threadsynchP.html" rel="external nofollow noopener noreferrer" target="_blank">监视器</a>是一个可以实现线程互斥和协作的结构。</p><p>监视器可以看作一个房子，这个房子有个只能被一个线程占有的特殊的房间，房间里保护的就是临界资源。</p><p><img src="/Wiki/wiki/Java/笔记/java-monitor-associate-with-object.jpg" alt="img"></p><p>如果一个线程需要进入特殊房间，首选需要在大门(Entry Set)中等待，由调度策略决定下一个进入房间的是哪个线程。如果线程由于某种原因被挂起，则进入Wait Set，在合适的时间会被安排到特殊房间里。</p><p>进入房子 - entering the monitor</p><p>进入特殊房间 - acquiring the monitor</p><p>占据特殊房间 - owning the monitor</p><p>离开特殊房间 - releasing the monitor</p><p>离开房子 - exiting the monitor</p><p><strong>Synchornized</strong>关键字就是将其包裹的代码块放入特殊房间里，线程需要先enter the monitor后进入entry set，之后acquire the monitor才能运行代码块。</p><p><strong>wait和notify</strong>也是利用monitor，原理是：当一个线程own the monitor时，可以调用wait方法来将自己挂起，release the monitor并进入到Wait Set中，直到其他在拥有monitor的线程调用notify方法。当线程调用notify时，并不是立马就release the monitor，只有当线程release the monitor后，等待线程才会去acquire the monitor，但是monitor也可能被其他线程获取到，因此即使wait线程获取到monitor，也需要检查下数据是否满足其想要的条件。</p><p><img src="/Wiki/wiki/Java/笔记/fig20-1.gif" alt="Figure 20-1. A Java monitor."></p><h3 id="synchronized锁的优化"><a href="#synchronized锁的优化" class="headerlink" title="synchronized锁的优化"></a>synchronized锁的优化</h3><p>Monitor中的互斥锁是OS层面来支持，在获取(monitor entry)和释放锁(monitor exit)时存在大量的开销。因此HotSpot VM在这方面做了些<a href="https://pdfs.semanticscholar.org/edf9/54412a9b1ce955bea148199f325759779540.pdf?_ga=2.63410607.1434231496.1554627760-821097055.1554627760" rel="external nofollow noopener noreferrer" target="_blank">优化</a>。</p><h4 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h4><p><a href="https://tech.meituan.com/2018/11/15/java-lock.html" rel="external nofollow noopener noreferrer" target="_blank">对象头</a>主要包含两部分数据：Mark Word、Klass Pointer(类型指针，用来确定是哪个类的实例)。</p><p><strong>Mark Word</strong>：存储了对象的HashCode、分代年龄和锁标志位信息。对象的状态不同，Mark Word里存储的信息也会不同。</p><p><img src="/Wiki/wiki/Java/笔记/image-20190410212710712.png" alt="image-20190410212710712"></p><h4 id="锁消除-Lock-Elision"><a href="#锁消除-Lock-Elision" class="headerlink" title="锁消除(Lock Elision)"></a>锁消除(Lock Elision)</h4><p>通过逃逸分析的技术，如果对象只会被一个线程使用，在编译成字节码的时候会去掉不必要的锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getFruits</span> <span class="params">(String... fruits )</span> </span>&#123;</span><br><span class="line">Vector v = <span class="keyword">new</span> Vector();</span><br><span class="line"><span class="keyword">for</span> (String fruit: fruits)</span><br><span class="line">v.add(fruit);</span><br><span class="line"><span class="keyword">return</span> v.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里v的引用不会逃出getFruits方法，因此Vector的synchronized锁可以去掉。</p><h4 id="锁粗化-Lock-Coarsening"><a href="#锁粗化-Lock-Coarsening" class="headerlink" title="锁粗化(Lock Coarsening)"></a>锁粗化(Lock Coarsening)</h4><p>如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Vector <span class="title">getFruits</span><span class="params">(Vector v)</span> </span>&#123;</span><br><span class="line">v.add(<span class="string">"Banana"</span>);</span><br><span class="line">v.add(<span class="string">"Melon"</span>);</span><br><span class="line"><span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每调一次add方法都有一次获取锁、释放锁的过程，编译器会用一个锁将它们包起来，这个过程叫做锁粗化。对于循环，锁粗化会导致锁长时间被一个线程持有，因此锁粗化只会应用于非循环的情况。</p><h4 id="自旋锁与自适应自旋锁"><a href="#自旋锁与自适应自旋锁" class="headerlink" title="自旋锁与自适应自旋锁"></a>自旋锁与自适应自旋锁</h4><p>阻塞或唤醒线程存在上下文切换的代价。因此出现了自旋锁，当发现自旋时间过长时，可以将其转化成重量级锁(即OS层面对锁)，因此称为自适应自旋锁。自旋锁的实现原理是CAS。</p><h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><p>大多数时候，不存在锁的竞争。轻量级锁是根据这个场景进行优化。</p><ol><li>拷贝对象头中的Mark Word到当前线程栈帧中的Lock Record</li><li>CAS将Mark Word的ptr指向线程Lock Record</li><li>成功则获取到锁，失败则自旋再尝试，自旋达到一定次数后膨胀为重量级锁。</li></ol><h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>大多数情况，锁总是被同一个线程获得，因此出现了偏向锁。</p><p>当锁对象第一次被线程获取时，虚拟机会将对象头中的标志位设为偏向模式，并通过CAS在Mark Word里存储当前线程ID，在线程进入或退出同步代码块时，不是去获取或释放锁，而是检测Mark Word里存储的线程ID是否与当前线程ID相同即可，因此相比自旋锁，偏向锁少了多处CAS的开销。如果相同，说明已经获取到锁，如果不同，说明偏向的是别的线程，这时候就应该撤销偏向锁，不能继续偏向原来的线程。偏向锁的撤销，需要在如下场景下：</p><p><img src="/Wiki/wiki/Java/笔记/v2-9db4211af1be81785f6cc51a58ae6054_r.jpg" alt="preview"></p><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><h4 id="volatile作用"><a href="#volatile作用" class="headerlink" title="volatile作用"></a>volatile作用</h4><p>在单核处理中，同一进程的不同线程访问共享数据时，CPU先将共享变量加载到共享缓存中，不同线程访问该数据时，都是访问的同一个地址，因此volatile的可见性就没有必要了。但是在多核处理器中，每个CPU都会从主存中将数据加载到其自身的缓存中，这时候就可能会出现缓存不一致的问题，当多线程运行在不同的CPU时，就可能导致每个线程看到的数据不一致，volatile就是为了解决这个问题。</p><p>volatile修饰的变量具有可见性，对一个volatile变量的写操作及这个写操作之前的所有操作Happens-Before对这个变量的读操作及这个读操作之后的所有操作。</p><h4 id="volatile实现原理"><a href="#volatile实现原理" class="headerlink" title="volatile实现原理"></a>volatile实现原理</h4><p>volatile需要借助硬件来实现。对volatile变量的写操作，会在正常汇编指令前加一个lock前缀的指令，这个指令在多核处理器会做<a href="http://www.importnew.com/27002.html" rel="external nofollow noopener noreferrer" target="_blank">两件事</a>。</p><ol><li>锁总线，其它CPU对内存的读写请求都会被阻塞，直到锁释放，由于锁总线期间其他CPU没法访问内存，因此其开销比较大，后来的处理器都采用锁缓存替代锁总线，通过缓存一致性协议来实现数据一致。缓存一致性协议有多种，常见的是通过嗅探来实现，通过不停的嗅探总线上的数据交换，从而当一个缓存代表它所属的处理器去读写内存时，其它处理器都会得到通知，它们以此来使自己的缓存保持同步。</li><li>lock后的写操作会回写已修改的数据，同时让其它CPU相关缓存行失效，从而重新从主存中加载最新的数据</li></ol><h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>每个线程保存一个变量的副本。</p><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><ol><li><p>方便传参数，A方法到F方法，中间经过了很多方法，现在需要从A多传一个参数到F，为了避免对中间方法对应用，可以用threadlocal来进行传参。</p></li><li><p>其实应用场景就跟其作用所说一样，需要使用与线程相关的数据时使用。</p></li></ol><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>已有的条件是什么？:</p><p>ThreadLocal变量，线程实例</p><p>求解的问题:</p><p>ThreadLocal实现原理</p><p>每个线程一个变量，通过ThreadLocal的方法获取到该值，很容易想到的就是Map。即线程实例为键，变量为值。那么这个map保存在哪呢？正常想到的想法是保存在ThreadLocal对象里，即ThreadLocal t 有个Map，这个Map保存了线程和其值的关系。但是线程对象大多数是临时对象，也就是说ThreaLocal的这个Map需要经常更新，不然就会保持对线程的引用，导致线程无法回收。既然线程的变量存活周期与线程是一样的，那么何不把这个变量保存在线程对象中呢，由于线程会有不同类型的threadlocal局部变量，因此需要一个字段能够包含这所有的threalocal，做法还是用map，key是ThreadLocal变量，而value是线程真正对应的值。<code>Entry(ThreadLocal&lt;?&gt; k, Object v)</code></p><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><h2 id="JVM内存区域"><a href="#JVM内存区域" class="headerlink" title="JVM内存区域"></a>JVM内存区域</h2><h3 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h3><h2 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h2><p>GC要做的三件事：</p><ol><li><p><strong>哪些内存需要回收(what)</strong></p></li><li><p><strong>什么时候回收(when)</strong></p></li><li><p><strong>怎么回收(how</strong>)</p></li></ol><h4 id="哪些内存需要回收"><a href="#哪些内存需要回收" class="headerlink" title="哪些内存需要回收"></a>哪些内存需要回收</h4><p>可达性分析，GC Roots Tracing：当对象与GC Roots没有引用链相连时，该对象为<strong>不可达对象</strong>。GC Roots包括如下</p><ol><li>System Class</li></ol><p>​            由bootstrap/system 类加载器加载的类</p><ol start="2"><li>Native Code</li></ol><p>​            Native code中的局部变量和全局变量</p><ol start="3"><li>Thread Block</li></ol><p>​            当前活跃线程里引用的对象</p><ol start="4"><li>Thread</li></ol><p>​            已启动的线程</p><ol start="5"><li><p>Stack Local</p><p>Java方法的local变量或参数 </p></li></ol><p>当一个对象被标记为不可达后，下一个垃圾回收会试图回收该对象，如果对象重写了finalize方法，并且在这个方法自救成功(将自身赋予某个引用)，则不会被回收，但是如果没有重写finalize或者已经执行过该方法，则自救失败。</p><p>什么时候回收要与怎么回收一起来看，Java主要采用了分代回收，将堆内存分成了新生代和老年代。</p><h4 id="怎么回收"><a href="#怎么回收" class="headerlink" title="怎么回收"></a>怎么回收</h4><p>通过垃圾收集器进行垃圾回收</p><p>垃圾回收分为三步：</p><ol><li><strong>标记</strong>(Mark)</li></ol><p>要进行垃圾回收，首先要确定哪些是垃圾嘛，这一步将对对象进行扫描，来确定哪些对象需要回收</p><ol start="2"><li><strong>清除</strong></li></ol><p>既然知道哪些对象要回收，那么这一步就从内存中删掉这些对象</p><p><img src="/Wiki/wiki/Java/笔记/clip_image002.png" alt="https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/images/gcslides/Slide1b.png"></p><ol start="3"><li><strong>整理</strong>(compact)</li></ol><p>如上所示，在清除时会产生内存碎片，可以在清除后进行整理，来清除内存碎片。</p><p>在上述步骤中，标记和整理是比较耗时的，随着对象越来越多，垃圾回收的时间也就越长，而实际上，一个应用的大多数对象其实存活时间是很短的，分代回收的思想是不同代的对象存活时间不一样，因此垃圾回收的频率应该也不一样，尽量做到：当开始垃圾回收时，能做到大多数对象被标记为可被回收，使得标记阶段做的活不是白费的。这就是<strong>为什么采用分代回收</strong>。</p><p>如图所示</p><p><img src="/Wiki/wiki/Java/笔记/clip_image003.png" alt="https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/images/gcslides/Slide5.png">大多数对象最初都被分配到新生代，对新生代里的对象的预期就是存活时间不长，当新生代区域满时，就会发生<strong>minor gc</strong>，当对象在新生代中存活超过一定的gc次数，就会被移动到老年代中，当老年代也需要回收时，此时会发生<strong>full gc。</strong></p><p><strong>GC流程如下：</strong></p><ol><li>对象首先放到eden区，eden区满时，发生minor gc，存活对象移动到S0，清除eden区。同时，对象被标记存活年龄。</li></ol><p><strong><img src="/Wiki/wiki/Java/笔记/clip_image004.png" alt="img"></strong></p><ol start="2"><li>下一次minor gc时，存活对象和S0的对象移动到S1，清除eden和S0区。</li></ol><p><strong><img src="/Wiki/wiki/Java/笔记/clip_image005.png" alt="img"></strong></p><ol start="3"><li>下一次，存活对象则从S1到S0，如此反复，当对象存活超过一定次数，移动到老年代。</li></ol><p><strong><img src="/Wiki/wiki/Java/笔记/clip_image006.png" alt="img"></strong></p><p>​            <strong>为什么设置S0、S1</strong>？首先，<strong>为什么需要survivor区</strong>？如果没有survivor区，eden区满了之后就会被送到老年代，这会导致很快发生Full GC。这些对象可能还是属于死得早的对象，只不过逃过了第一次垃圾回收，设置S区作为缓冲区可以使得这些年轻对象仍在年轻代被回收。<strong>为什么需要两个S区</strong>？主要是为了避免内存碎片，如果只有一个，那么在第二次minor gc时，可能eden和survivor区都会有部分对象存活，如果把eden区存活对象放到s区，很明显会产生内存碎片。为了避免内存碎片，新增一个s区，将所有存活对象移动到另一个空的s区中去。</p><p>​            <strong>Full GC具体什么时候发生</strong>？前面说到当老年代需要回收时，会触发Full GC。那么什么时候会触发呢，1. 当老年代空间不足时，空间不足包括几种可能：创建大对象、大数组，老年代没有足够大的连续空间时；新生代转入导致空间不足。2.Metaspace空间不足。3.System.gc()方法的调用，这个方法是建议虚拟机进行Full GC，很多时候确实也会导致Full GC。</p><p>​            <strong>存活的对象Survivor区放不下怎么办</strong>？如果Survivor区太小，放不下的对象会被直接放到老年代，如果Survivor区太大，则会造成无用的浪费。虚拟机会在每次垃圾回收时设置一个threshold，对象被晋升到老年代时的存活次数，这个值保证survivor区的剩余空间大概在一半左右。</p><h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><p>对年轻代和老年代，可以采用不同的垃圾回收算法。</p><h4 id="Serial-GC"><a href="#Serial-GC" class="headerlink" title="Serial GC"></a><strong>Serial GC</strong></h4><p>单线程进行垃圾回收，没有线程间通信开销，效率比较高，适用于单处理器的机器。</p><p>也适用于一台机器上运行多个JVM(超过处理器数量)的情况，可以避免多线程回收对其他JVM的影响。还适用于对停顿时间要求不是很高的场景。</p><h4 id="Parallel-GC"><a href="#Parallel-GC" class="headerlink" title="Parallel GC"></a><strong>Parallel GC</strong></h4><p>并行执行年轻代的垃圾回收，适用于对系统吞吐量要求较高的环境。</p><h4 id="Concurrent-GC"><a href="#Concurrent-GC" class="headerlink" title="Concurrent GC"></a><strong>Concurrent GC</strong></h4><p>减少应用的停顿时间。</p><p>应用可以对年轻代和老年代配置一组相互兼容的垃圾收集器。如下图所示。</p><p><img src="/Wiki/wiki/Java/笔记/clip_image008.png" alt="gc-collectors-pairing"></p><p>stop-the-world pause: 只使应用线程全部暂停的垃圾回收。</p><p>所有的垃圾回收在minor gc时都会有stop-the-world pause，但是在full gc时，CMS和G1收集器与其他垃圾收集器的区别在于它们可以在标记阶段做到没有停顿，不过代价是占用更多的CPU资源。</p><h4 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h4><p>CMS收集器使用一个或多个线程在后台定期对老年代进行回收。但是由于不进行整理操作，会产生内存碎片。</p><h4 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h4><p>G1收集器将堆分为了许多region。</p><p>堆大小什么时候扩容</p><p>MetaSpace大小设置过大导致发生Full GC</p><h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><h3 id="线程池的作用"><a href="#线程池的作用" class="headerlink" title="线程池的作用"></a>线程池的作用</h3><ol><li>线程的创建和销毁消耗资源，因此通过池技术来达到复用。</li><li>对线程进行管控，线程创建无限制的话，对整个系统可能造成致命影响。</li><li>根据业务创建线程池，可以对业务进行隔离，避免相互影响。</li></ol><h3 id="Java线程池"><a href="#Java线程池" class="headerlink" title="Java线程池"></a>Java线程池</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, RejectedExecutionHandler handler)</span><br></pre></td></tr></table></figure><p>重要参数</p><ul><li><code>corePoolSize</code> 池中的线程基本个数</li><li><code>maximumPoolSize</code> 最大线程个数</li><li><code>keepAliveTime</code> 当线程个数大于<code>corePoolSize</code>时，线程空闲时的最大存活时间</li><li><code>workQueue</code> 存放任务的阻塞队列</li><li><code>handler</code> 当队列和最大线程池都满了之后的饱和策略。</li></ul><p>通过<code>threadPool.execute(**new** Job())</code>提交一个任务后，经历如下几个步骤</p><p><img src="/Wiki/wiki/Java/笔记/image-20190401131756815.png" alt="image-20190401131756815"></p><p>线程池提供了四种拒绝策略，也可以自己实现接口自定义饱和策略：</p><p>1、AbortPolicy：直接抛出异常，默认策略；<br>2、CallerRunsPolicy：用调用者所在的线程来执行任务；<br>3、DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务；<br>4、DiscardPolicy：直接丢弃任务；</p><p>线程池配置的合理性主要还是需要通过测试验证来确定。基本原则是：线程等待时间所占比例越高，需要越多线程；线程cpu时间所占比例越高，需要越少线程。</p><h3 id="Thread-run-和Thread-start-区别"><a href="#Thread-run-和Thread-start-区别" class="headerlink" title="Thread.run()和Thread.start()区别"></a>Thread.run()和Thread.start()区别</h3><p>run方法就是个普通方法，可以被重复调用，不能起到多线程的目的；调用start方法，会启动新的线程，线程获取到时间片后，会运行run方法，<strong>start不能被重复调用，为什么呢</strong>？如果在一个Thread对象执行<a href="https://stackoverflow.com/questions/2663426/why-cant-we-call-the-start-method-twice-on-a-same-instance-of-the-thread-object" rel="external nofollow noopener noreferrer" target="_blank">多次并发操作</a>，那么getStackTrace() and getState()应该返回什么？</p><h3 id="创建线程有哪几种方式"><a href="#创建线程有哪几种方式" class="headerlink" title="创建线程有哪几种方式"></a>创建线程有哪几种方式</h3><ol><li>实现Runnable接口，重写run<a href="https://juejin.im/post/5aa12936f265da238d504b7c" rel="external nofollow noopener noreferrer" target="_blank">方法</a></li><li>继承Thread，重写run方法，Thread实现了Runnable接口，与方法1其实原理一样</li><li>实现Callable接口，结合FutureTask使用</li></ol><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h3 id="解决哈希冲突的方法"><a href="#解决哈希冲突的方法" class="headerlink" title="解决哈希冲突的方法"></a>解决哈希冲突的方法</h3><p>常用方法有开放地址法(Python 字典<a href="https://www.kawabangga.com/posts/2493" rel="external nofollow noopener noreferrer" target="_blank">实现</a>)、拉链法(Java HashMap实现)。<a href="https://www.jianshu.com/p/4d3cb99d7580" rel="external nofollow noopener noreferrer" target="_blank">参考</a></p><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h2><p>进程是一个资源的容器，为进程里的所有线程提供共享资源，进程是系统资源分配的单位，线程是系统调度的单位。</p><p>线程有自己独立的程序计数器和栈，一个进程内的线程共享地址空间，创建和销毁线程的开销比进程小。线程依赖于进程而存在。</p><p>进程间通信比线程间通信要复杂。</p><h2 id="多线程和多进程如何选择"><a href="#多线程和多进程如何选择" class="headerlink" title="多线程和多进程如何选择"></a>多线程和多进程如何选择</h2><p>多进程的系统鲁棒性更好，适合于分布式场景，内存地址空间隔离，对于不需要共享数据的情况下，可以使用多进程。</p><p>线程创建和销毁的开销小，对于一些服务器响应任务，所需线程数量经常变化的场景适合用多线程，而不适合用多进程。线程间可以共享内存地址空间，这也是需要多线程的原因。</p><p>强相关的处理用线程，弱相关的处理用进程。多线程更方便于功能的内聚，更有力的进行资源的共享，多进程更方便于功能的可拆分，但多进程会导致资源共享的困难。需要多任务进行大量CPU计算的适合用多线程，因为线程切换比较快。</p><p>可能要扩展到多机分布的用进程，实际应用中都是进程+线程的结合方式</p><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="四种隔离级别"><a href="#四种隔离级别" class="headerlink" title="四种隔离级别"></a>四种隔离级别</h2><h3 id="读未提交"><a href="#读未提交" class="headerlink" title="读未提交"></a>读未提交</h3><p>读不会加锁，其他事务在写的时候会加<strong>排它锁</strong>(排它锁会阻止其它事务再对其锁定的数据加读或写的锁，但是对不加锁的读无影响)。</p><h3 id="读已提交"><a href="#读已提交" class="headerlink" title="读已提交"></a>读已提交</h3><p>MVCC机制实现，MVCC版本的生成时机是每次select时，因此会出现<strong>不可重复读</strong>现象。</p><h3 id="可重复读隔离级别的底层实现"><a href="#可重复读隔离级别的底层实现" class="headerlink" title="可重复读隔离级别的底层实现"></a>可重复读隔离级别的底层实现</h3><p>MVCC机制，一次事务中，只在<strong>第一次select</strong>时生成版本，后续的查询都是在这个版本上进行，从而实现了<strong>可重复读</strong>。但是因为MVCC的快照只对<strong>读操作</strong>有效，对<strong>写操作</strong>无效，举例说明会更清晰一点： 事务A依次执行如下3条sql，事务B在语句1和2之间，插入10条age=20的记录，事务A就<strong>幻读</strong>了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. select count(1) from user where age=20;</span><br><span class="line">-- return 0: 当前没有age=20的</span><br><span class="line">2. update user set name=test where age=20;</span><br><span class="line">-- Affects 10 rows: 因为事务B刚写入10条age=20的记录，而写操作是不受MVCC影响，能看到最新数据的，所以更新成功，而一旦操作成功，这些被操作的数据就会对当前事务可见</span><br><span class="line">3. select count(1) from user where age=20;</span><br><span class="line">-- return 10: 出现幻读</span><br></pre></td></tr></table></figure><p>REPEATABLE READ级别，可以防止大部分的幻读，但像前边举例读-写-读的情况，使用不加锁的select依然会幻读。</p><h3 id="Serializable"><a href="#Serializable" class="headerlink" title="Serializable"></a>Serializable</h3><p>读加共享锁，写加排他锁，读写互斥。</p><h2 id="为什么索引快"><a href="#为什么索引快" class="headerlink" title="为什么索引快"></a>为什么索引快</h2><ol><li>索引块的数量比数据块数量少</li><li>键被排序，可以使用查找算法高效查找</li><li>索引文件可能足够小，以至于可以永久存放在主存缓冲区中</li></ol><h2 id="哪些情况下不会使用索引"><a href="#哪些情况下不会使用索引" class="headerlink" title="哪些情况下不会使用索引"></a>哪些情况下不会使用索引</h2><ul><li>全表扫描比使用索引快，不会使用索引</li><li>like是以%开头</li><li>潜在的数据类型转换</li><li>索引列参与了函数运算</li><li>or关键字，其中一个字段没索引</li></ul><h3 id="B-树和B树的区别"><a href="#B-树和B树的区别" class="headerlink" title="B+树和B树的区别"></a>B+树和B树的区别</h3><p>B树是充分利用磁盘预读功能而创建的一种数据结构，B树的每个节点可以存储多个关键字，它将节点大小设置为磁盘页的大小，充分利用了<strong>磁盘预读</strong>的功能。每次读取磁盘页时就会读取一整个节点。也正因每个节点存储着非常多个关键字，<strong>树的深度就会非常的小</strong>。进而要执行的<strong>磁盘读取操作次数就会非常少</strong>，更多的是在内存中对读取进来的数据进行查找。</p><p>B+树的内部节点并没有指向关键字具体信息的指针，因此其内部节点大小比B树小，<strong>同一磁盘块所能容纳的关键字数量也更多</strong>，一次能读入内存中的关键字也就越多，IO读写次数也就降低了。</p><p>B+树基于范围的查询更简洁，因为叶子节点有指向下一个叶子节点的指针。</p><p>B+树的查询效率更加稳定。任何关键字的查找必须走一条从根结点到叶子结点的路。</p><h3 id="CBO"><a href="#CBO" class="headerlink" title="CBO"></a>CBO</h3><p>CBO会从目标sql诸多可能的执行路径中选择一条成本值(消耗的I/O和CPU资源)最小的执行路径来作为其执行计划。</p><h4 id="cbo的缺陷"><a href="#cbo的缺陷" class="headerlink" title="cbo的缺陷"></a>cbo的缺陷</h4><p>cbo的缺陷就在于它可能会选错执行计划。</p><ol><li>解析多表关联的sql时，可能的执行路径太多，不可能全部遍历。</li><li>假设sql都是单独执行的，没有考虑缓存。。。。</li></ol><p>索引全扫描(INDEX FULL SCAN)，扫描目标索引所有叶子块的所有索引行。</p><p>走索引全扫描能够达到排序的效果，避免了对该索引的索引键值列的真正排序操作。</p><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="如何写好while-loop"><a href="#如何写好while-loop" class="headerlink" title="如何写好while loop"></a>如何写好while loop</h2><p>需要思考如下几点：</p><ol><li>从上一迭代到下一迭代是怎么转变的，涉及什么数据变化，数据怎么变化</li><li>迭代的终止条件是什么</li></ol><h3 id="uuid的作用，优缺点"><a href="#uuid的作用，优缺点" class="headerlink" title="uuid的作用，优缺点"></a>uuid的作用，优缺点</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java&quot;&gt;&lt;a href=&quot;#Java&quot; class=&quot;headerlink&quot; title=&quot;Java&quot;&gt;&lt;/a&gt;Java&lt;/h1&gt;&lt;h2 id=&quot;搜索技巧&quot;&gt;&lt;a href=&quot;#搜索技巧&quot; class=&quot;headerlink&quot; title=&quot;搜索技巧&quot;&gt;&lt;/a
      
    
    </summary>
    
      <category term="Java" scheme="http://polyval.github.io/Wiki/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>HashMap</title>
    <link href="http://polyval.github.io/Wiki/wiki/Java/HashMap/"/>
    <id>http://polyval.github.io/Wiki/wiki/Java/HashMap/</id>
    <published>2018-11-05T13:28:21.000Z</published>
    <updated>2018-11-07T14:45:57.253Z</updated>
    
    <content type="html"><![CDATA[<h1 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h1><p>HashMap内部采用<strong>数组+链表+红黑树</strong>来实现。如下图所示。</p><p><img src="/Wiki/wiki/Java/HashMap/hashMap.png" alt="hashMap"></p><p>Node是HashMap的内部类，用来表示一个键值对，实现了Map.Entry接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;    <span class="comment">//用来定位数组索引位置</span></span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K,V&gt; next;   <span class="comment">//链表的下一个node</span></span><br><span class="line"></span><br><span class="line">        Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span></span>&#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>几个重要字段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> threshold;      <span class="comment">// 所能容纳的key-value对极限 </span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;  <span class="comment">// 负载因子，默认为0.75</span></span><br><span class="line"><span class="comment">// 内部结构发生变化的次数，迭代器遍历时若发生变化会抛出ConcurrentModificationException异常</span></span><br><span class="line"><span class="keyword">int</span> modCount;</span><br><span class="line"><span class="keyword">int</span> size; <span class="comment">// 实际存的键值对数量</span></span><br><span class="line">Node&lt;K,V&gt;[] table  <span class="comment">// 数组</span></span><br></pre></td></tr></table></figure><p>当 <code>size &gt; (threshold = table.length * loadFactor)</code>时，就要对数组进行扩容，数组扩容后的大小是原来的两倍。</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="hash算法"><a href="#hash算法" class="headerlink" title="hash算法"></a>hash算法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 来定位哈希桶数组索引位置</span></span><br><span class="line">tab[i = (n - <span class="number">1</span>) &amp; hash]</span><br></pre></td></tr></table></figure><p>通过key的hashCode()的高16位异或低16位来计算hash，使得高低bit都参与到hash计算来。计算hash后，需要根据hash值确定键值对在数组中的位置。一般通过对数组取模h%length来确定，这里通过<code>(n - 1) &amp; hash</code>同样达到了取模的目的，但是效率更高。下面证明下：</p><blockquote><p>X % 2^n = X &amp; (2^n – 1)</p><p>2^n表示成2进制就是1000…0(n个0)。2^n - 1为0111..11(n个1)。</p><p>此时X &amp; (2^n – 1) 就相当于取X的2进制的最后n位数。</p><p>从2进制角度来看，X / 2^n相当于 X &gt;&gt; n，即把X右移n位，此时得到了X / 2^n的商，而被移掉的部分(后n位)，则是X % 2^n，也就是余数。</p></blockquote><h2 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h2><p>put方法流程如下图</p><p><img src="/Wiki/wiki/Java/HashMap/hashMap-put.png" alt="hashMap put"> </p><h2 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 超过最大值就不扩容了</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 扩充为原来的2倍</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="comment">// 重点在这下面，上面是确定容量的，这里进行数组转移，以一个新数组替换原来的</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">    <span class="comment">// 构建新的数组</span></span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 遍历老数组的Node</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 便于GC</span></span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// 链表就一个元素，直接放到新数组</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="comment">// 是红黑树节点，节点数超过8</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="comment">// 正常链表</span></span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        <span class="comment">// 循环遍历链表的节点</span></span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">// 分为两种情况，链表上节点会分到两个桶下面</span></span><br><span class="line">                     <span class="comment">// 这里进行链表的拆分</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 将链表放入新数组中，Node的先后顺序没有变</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// e.hash * old_n == 1 的放在新数组[j+old_n]位置处</span></span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面说了通过<code>(n - 1) &amp; hash</code>来确定Node在数组中的位置，扩容后n变为原来的2倍。也就是说n-1与扩容前相比其位标志上左边多出一位为1，这时候与hash进行与计算，则计算结果取决于该位上hash是0还是1，如果是0，则计算结果与扩容前一致，如果是1，则该位结果为1，即为原来的值+扩容前的n值。</p><p>在Java7中，链表在转移的时候顺序会被导致，多线程resize的时候会形成环形链表导致put时出现死循环，Java8已经没这个问题了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;存储结构&quot;&gt;&lt;a href=&quot;#存储结构&quot; class=&quot;headerlink&quot; title=&quot;存储结构&quot;&gt;&lt;/a&gt;存储结构&lt;/h1&gt;&lt;p&gt;HashMap内部采用&lt;strong&gt;数组+链表+红黑树&lt;/strong&gt;来实现。如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img sr
      
    
    </summary>
    
      <category term="Java" scheme="http://polyval.github.io/Wiki/categories/Java/"/>
    
    
      <category term="Java" scheme="http://polyval.github.io/Wiki/tags/Java/"/>
    
      <category term="集合" scheme="http://polyval.github.io/Wiki/tags/%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>CountDownLatch&amp;CyclicBarrier</title>
    <link href="http://polyval.github.io/Wiki/wiki/Java/CountDownLatch/"/>
    <id>http://polyval.github.io/Wiki/wiki/Java/CountDownLatch/</id>
    <published>2018-11-03T12:18:21.000Z</published>
    <updated>2018-11-05T04:52:33.302Z</updated>
    
    <content type="html"><![CDATA[<p><code>CountDownLatch</code>的作用是使得一个或多个线程等待直到其他线程完成操作。</p><p><code>CyclicBarrier</code>的作用是可以让一组线程达到一个屏障时被阻塞，直到最后一个线程达到屏障时，所有被阻塞的线程才能继续执行。</p><p>实际场景：多线程去后台查数据，需要所有数据全部获取到后再处理。</p><h1 id="CountDownLatch原理"><a href="#CountDownLatch原理" class="headerlink" title="CountDownLatch原理"></a><code>CountDownLatch</code>原理</h1><p>还是利用AQS来实现，其对外暴露的三个重要方法为。</p><ul><li>CountDownLatch(int) 其实就是设置sync的state。这个值表示countDown方法需要被调用多少次调用await的方法才会被唤醒。</li><li>await，调用的是sync.acquireSharedInterruptibly(1); 调用该方法的线程会阻塞到state为0</li><li>countDown，调用的是sync.releaseShared(1); 调用该方法state计数减1</li></ul><p>原理很简单。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 阻塞到state为0</span><br><span class="line">protected int tryAcquireShared(int acquires) &#123;</span><br><span class="line">    return (getState() == 0) ? 1 : -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected boolean tryReleaseShared(int releases) &#123;</span><br><span class="line">    // Decrement count; signal when transition to zero</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        int c = getState();</span><br><span class="line">        if (c == 0)</span><br><span class="line">            return false;</span><br><span class="line">        // 计数减1</span><br><span class="line">        int nextc = c-1;</span><br><span class="line">        if (compareAndSetState(c, nextc))</span><br><span class="line">            return nextc == 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a><code>CyclicBarrier</code></h1><p>一个高级队构造函数：CyclicBarrier(int parties, Runnable barrierAction)，barrierAction任务会在所有线程到达屏障后执行。</p><h1 id="CyclicBarrier和CountDownLatch区别"><a href="#CyclicBarrier和CountDownLatch区别" class="headerlink" title="CyclicBarrier和CountDownLatch区别"></a><code>CyclicBarrier</code>和<code>CountDownLatch</code>区别</h1><p><code></code>CountDownLatch<code>的计数器只能使用一次，</code>CyclicBarrier<code>可以用</code>reset`方法将计数器重置。因此CyclicBarrier可以处理更加复杂的业务场景。CountDownLatch一般用于某些线程等待若干个其他线程执行完任务之后，它才执行；而CyclicBarrier一般用于一组线程互相等待至某个状态，然后这一组线程再同时执行；</p><h1 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h1><p><code>Semaphore</code>可以用来控制同时访问特定资源的线程数量。实现比较简单，可参看<a href="https://www.jianshu.com/p/0090341c6b80" rel="external nofollow noopener noreferrer" target="_blank">Semaphore</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;CountDownLatch&lt;/code&gt;的作用是使得一个或多个线程等待直到其他线程完成操作。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;CyclicBarrier&lt;/code&gt;的作用是可以让一组线程达到一个屏障时被阻塞，直到最后一个线程达到屏障时，所有被阻塞的线程才能继续执行
      
    
    </summary>
    
      <category term="Java" scheme="http://polyval.github.io/Wiki/categories/Java/"/>
    
    
      <category term="Java" scheme="http://polyval.github.io/Wiki/tags/Java/"/>
    
      <category term="并发" scheme="http://polyval.github.io/Wiki/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>ReentrantLock</title>
    <link href="http://polyval.github.io/Wiki/wiki/Java/ReentrantLock/"/>
    <id>http://polyval.github.io/Wiki/wiki/Java/ReentrantLock/</id>
    <published>2018-11-01T03:28:21.000Z</published>
    <updated>2018-11-02T11:49:21.140Z</updated>
    
    <content type="html"><![CDATA[<p><code>ReentrantLock</code>实现了<code>Lock</code>的接口。<code>ReentrantLock</code>相比<code>synchronized</code>提供了更多的功能。<code>Lock</code>接口的方法如下</p><ul><li>lock </li><li>lockInterruptibly，可中断的锁获取操作，在获取锁的过程中，线程可以响应中断。被中断时会抛出InterruptedException。</li><li>tryLock，非阻塞的获取锁，获取不到就立即返回。</li><li>tryLock(time)，超时获取锁，以下情况会返回：时间内获取到了锁，时间内被中断，时间到了没有获取到锁。</li><li>unlock</li><li>condition 获取条件实例。</li></ul><h1 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h1><p><code>ReentrantLock</code>是可重入锁，什么是可重入锁呢，可重入锁是可重复可递归调用的锁，同一个线程外层函数获取到锁后，内层函数仍然有获取锁的代码，但不受影响。如果锁不可重入，则在线程再次调用获取锁的方法时，会发现锁被持有而发生死锁。如下代码，同一个线程调用lock方法两次，第二次则会发生死锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread current = Thread.currentThread();</span><br><span class="line">        <span class="comment">//这句是很经典的“自旋”语法</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!owner.compareAndSet(<span class="keyword">null</span>, current)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ReentrantLock</code>通过一个计数器来实现可重入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里判断是否当前线程获取到锁</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="comment">// 最大可重入次数限制。</span></span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么要用计数器，因为获取多少次锁就要释放多少次，如果最里面一层释放了锁就直接把锁释放掉了，那么原来外层有锁的逻辑就被改变了，外层此时处于没锁的状态。</p><h1 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h1><p><code>ReentrantLock</code>提供了两种锁的实现。公平锁和非公平锁，所谓公平锁是指线程获取锁的顺序按照排队顺序来，而非公平锁获取锁的顺序不定。</p><p><code>Sync</code>继承自<code>AQS</code>，而<code>FairSync</code> 和<code>NonfairSync</code>继承自<code>Sync</code>来实现公平锁和非公平锁。</p><p>先来看看非公平锁的lock方法，公平锁和非公平锁也就这两个方法有区别。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 快速CAS来获取锁</span></span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// CAS获取失败通过AQS中的acquire方法来获取，将state设为1</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 参看上节中代码，支持了可重入</span></span><br><span class="line">    <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>公平锁的lock方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Fair version of tryAcquire.  Don't grant access unless</span></span><br><span class="line"><span class="comment"> * recursive call or no waiters or is first.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">// 没有获取到锁</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断前面没有节点才会去获取锁，前面有节点时acquire方法会将其加入到同步队列，进队列后就可以保证FIFO。两者结合保证了公平锁的实现。</span></span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两种锁的unlock方法一样。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 计数器减1        </span></span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">       <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">       <span class="comment">// 表示完全释放掉锁</span></span><br><span class="line">       <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">           free = <span class="keyword">true</span>;</span><br><span class="line">           setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">       &#125;</span><br><span class="line">    <span class="comment">// 设置state为减后的</span></span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="公平锁和非公平锁的区别"><a href="#公平锁和非公平锁的区别" class="headerlink" title="公平锁和非公平锁的区别"></a>公平锁和非公平锁的区别</h2><p>公平锁的整体吞吐量往往不高，但是可以防止<strong>饥饿现象</strong>。非公平锁线程切换次数要少些，所以吞吐量较高。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;ReentrantLock&lt;/code&gt;实现了&lt;code&gt;Lock&lt;/code&gt;的接口。&lt;code&gt;ReentrantLock&lt;/code&gt;相比&lt;code&gt;synchronized&lt;/code&gt;提供了更多的功能。&lt;code&gt;Lock&lt;/code&gt;接口的方法如下&lt;
      
    
    </summary>
    
      <category term="Java" scheme="http://polyval.github.io/Wiki/categories/Java/"/>
    
    
      <category term="Java" scheme="http://polyval.github.io/Wiki/tags/Java/"/>
    
      <category term="并发" scheme="http://polyval.github.io/Wiki/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>ReentrantReadWriteLock</title>
    <link href="http://polyval.github.io/Wiki/wiki/Java/ReentrantReadWriteLock/"/>
    <id>http://polyval.github.io/Wiki/wiki/Java/ReentrantReadWriteLock/</id>
    <published>2018-10-31T23:28:21.000Z</published>
    <updated>2018-11-04T12:40:26.250Z</updated>
    
    <content type="html"><![CDATA[<p><code>ReentrantReadWriteLock</code>是读写锁，其维护了一对锁，一个读锁和一个写锁，读写锁在同一时刻可以允许多个读线程访问，在写线程访问时，则所有线程均被阻塞。适用于读多写少的场景。</p><p>如何在一个int变量上维护多个读线程和一个写线程的状态。读写锁将int变量分成了两个部分，<strong>高16位表示读，低16位表示写</strong>。通过位运算来实现状态的改变。</p><h1 id="写锁"><a href="#写锁" class="headerlink" title="写锁"></a>写锁</h1><p>写锁是独占锁，获取锁时重写tryAcquire即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Walkthrough:</span></span><br><span class="line"><span class="comment">     * 1. If read count nonzero or write count nonzero</span></span><br><span class="line"><span class="comment">     *    and owner is a different thread, fail.</span></span><br><span class="line"><span class="comment">     * 2. If count would saturate, fail. (This can only</span></span><br><span class="line"><span class="comment">     *    happen if count is already nonzero.)</span></span><br><span class="line"><span class="comment">     * 3. Otherwise, this thread is eligible for lock if</span></span><br><span class="line"><span class="comment">     *    it is either a reentrant acquire or</span></span><br><span class="line"><span class="comment">     *    queue policy allows it. If so, update state</span></span><br><span class="line"><span class="comment">     *    and set owner.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">//获取代表写锁的值，采用位运算来实现</span></span><br><span class="line">    <span class="keyword">int</span> w = exclusiveCount(c);</span><br><span class="line">    <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// (Note: if c != 0 and w == 0 then shared count != 0)</span></span><br><span class="line">        <span class="comment">// 存在读锁或者当前线程不是已经获取写锁的线程</span></span><br><span class="line">        <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        <span class="comment">// Reentrant acquire</span></span><br><span class="line">        setState(c + acquires);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在c=0时即没有读锁和写锁时，非公平锁会交给AQS去创建头节点然后获取再次调用获取锁</span></span><br><span class="line">    <span class="keyword">if</span> (writerShouldBlock() ||</span><br><span class="line">        !compareAndSetState(c, c + acquires))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    setExclusiveOwnerThread(current);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在读锁存在的时候，写锁不能被获取</strong>，原因在于：读写锁要保证写锁的操作要对读锁可见，如果存在读锁时写锁获取到，写线程的操作就对读线程不可见。而写锁一旦被获取，则其他读写线程的后续访问就会被阻塞。</p><p>方法<code>writerShouldBlock</code>由Sync的子类来实现，以此来区分公平锁和非公平锁。</p><p>写锁的释放操作和<code>ReentrantLock</code>类似，需要保证可重入性。</p><h1 id="读锁"><a href="#读锁" class="headerlink" title="读锁"></a>读锁</h1><p>读锁是共享锁，利用<code>tryAcquireShared</code>和<code>tryReleaseShared</code>来进行锁的获取和释放。如果其他线程已经获取了写锁，则当前线程获取读锁失败，进入等待状态，如果当前线程获取了写锁或者写锁未被获取，则当前线程增加读状态，获取读锁。</p><p>读锁的每次释放都会减少读状态。注意在增加读状态和减少读状态时都需要保证线程安全(CAS)，因为可能有多个线程对状态进行修改。</p><h1 id="锁降级"><a href="#锁降级" class="headerlink" title="锁降级"></a>锁降级</h1><p>锁降级指的是写锁降级成为读锁：获取到写锁，再获取到读锁，随后释放写锁的过程。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;ReentrantReadWriteLock&lt;/code&gt;是读写锁，其维护了一对锁，一个读锁和一个写锁，读写锁在同一时刻可以允许多个读线程访问，在写线程访问时，则所有线程均被阻塞。适用于读多写少的场景。&lt;/p&gt;
&lt;p&gt;如何在一个int变量上维护多个读线程和一个写
      
    
    </summary>
    
      <category term="Java" scheme="http://polyval.github.io/Wiki/categories/Java/"/>
    
    
      <category term="Java" scheme="http://polyval.github.io/Wiki/tags/Java/"/>
    
      <category term="并发" scheme="http://polyval.github.io/Wiki/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Condition</title>
    <link href="http://polyval.github.io/Wiki/wiki/Java/Condition/"/>
    <id>http://polyval.github.io/Wiki/wiki/Java/Condition/</id>
    <published>2018-10-28T03:28:21.000Z</published>
    <updated>2018-11-09T04:38:20.210Z</updated>
    
    <content type="html"><![CDATA[<p>Condition接口定义的几个方法如下：</p><p><img src="/Wiki/wiki/Java/Condition/image-20181029220107248.png" alt="image-20181029220107248"></p><p>其中，await方法类似于Object的wait方法，而signal和signalAll则分别对应于notify和notifyAll方法。</p><p>Condition其实现类在AQS中以内部类ConditionObject的形式存在。condition由锁的方法Lock.newCondition()来获取，且一个Lock可获取多个Condition，而不像Object只能设置一个条件。</p><p>下面说一下ConditionObject的await和signal方法。</p><h2 id="await"><a href="#await" class="headerlink" title="await"></a>await</h2><p>在调用该方法时，当前线程需要获取到与该Condition关联的锁，如果不加锁进入该方法，可能会导致其他线程调用signal方法时，还没进入到await方法，导致这个信号丢失，而不起任何效果。调用该方法后，线程释放锁，进入睡眠状态，在以下四种情况下线程会被唤醒</p><ul><li><p>其他线程调用<strong>signal</strong>方法，当前线程恰好被选中唤醒</p></li><li><p>其他线程调用<strong>signalAll</strong>方法</p></li><li><p>被其他线程<strong>中断</strong></p><blockquote><p>中断是让线程停止当前所做的事去做别的事情的一个标志。停止当前所做的事不代表线程就占用CPU在做什么，线程在睡眠也叫做线程所做的事。调用Thread.interrupt()方法可以设置目标线程的中断状态，至于线程如何响应中断，则看程序是如何写的。</p></blockquote></li><li><p>发生虚假唤醒(spurious wakeup)</p></li></ul><p>虚假唤醒时指线程在没有收到线程唤醒信号的时候醒了过来。await方法在jvm执行时实质是调用了底层<code>pthread_cond_wait</code>/<code>pthread_cond_timedwait</code>函数，而<code>pthread_cond_wait</code>可能在没收到信号时返回。同时，由于编码不规范也会产生虚假唤醒，举个例子</p><blockquote><p>线程A获取锁，发现队列空，因此wait，线程B向队列插入数据，改变条件变量，发出signal，线程C获取到锁，将数据移除，等到A获取锁从wait状态醒来时，应该是去队列移除数据的，但是此时的队列已经为空，这个唤醒是虚假唤醒。</p></blockquote><p><code>pthread_cond_wait</code>的作者认为既然编程不规范也会导致虚假唤醒，那么就交由上层来避免虚假唤醒，而不是底层来实现。</p><p>由于虚假唤醒的存在，await方法应该在循环中调用。</p><p>await的基本流程如下：</p><ol><li>生成并添加代表线程的Node节点到条件队列</li><li>释放锁</li><li>阻塞直到Node被移到同步队列</li><li>重新获取锁 </li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line"> <span class="comment">//新节点入条件队列</span></span><br><span class="line">    Node node = addConditionWaiter();</span><br><span class="line">    <span class="comment">//当前线程已持有锁，但由于要被阻塞，为不影响其他线程，需要先释放锁</span></span><br><span class="line">    <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">    <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 阻塞直到Node被移到锁队列</span></span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        <span class="comment">// 阻塞</span></span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 检测中断，一旦发生中断</span></span><br><span class="line"><span class="comment">         *  1.将条件队列中因中断而唤醒的节点进行转移(注意此处是中断)</span></span><br><span class="line"><span class="comment">         *  2.退出循环 -&gt; 接下来会在循环外进行中断处理</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重新尝试获取同步锁，获取成功后且被中断，当中断模式为抛出异常时，需要设置为重新中断，补充：acquireQueued会返回获取锁过程中线程是否有过中断，true则说明发生过中断</span></span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    <span class="comment">// 若当前节点存在后继节点时，需要执行出队操作</span></span><br><span class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    <span class="comment">//interruptMode != 0 说明是需要进行中断处理的</span></span><br><span class="line">    <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">        <span class="comment">//执行中断处理</span></span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Signal"><a href="#Signal" class="headerlink" title="Signal"></a>Signal</h2><p>signal做的事情</p><ol><li>清除节点： 从条件队列中移除第一个节点</li><li>节点转移： 将条件节点转换为同步节点，即从条件队列转移到同步队列</li><li>唤醒节点： 将转移成功的节点重新唤醒 </li></ol><p>当cancellation(超时或者中断)和signal几乎同时发生时，会存在竞争，根据Java规范，如果中断先发生，await在重新获取到锁后，抛出InterruptException，如果中断后于signal，则不抛出异常，只需修改线程中断的标志位。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Condition接口定义的几个方法如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/Wiki/wiki/Java/Condition/image-20181029220107248.png&quot; alt=&quot;image-20181029220107248&quot;&gt;&lt;/p&gt;
&lt;p&gt;其中，aw
      
    
    </summary>
    
      <category term="Java" scheme="http://polyval.github.io/Wiki/categories/Java/"/>
    
    
      <category term="Java" scheme="http://polyval.github.io/Wiki/tags/Java/"/>
    
      <category term="并发" scheme="http://polyval.github.io/Wiki/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>CAS</title>
    <link href="http://polyval.github.io/Wiki/wiki/Java/CAS/"/>
    <id>http://polyval.github.io/Wiki/wiki/Java/CAS/</id>
    <published>2018-10-23T03:28:21.000Z</published>
    <updated>2018-11-01T13:46:37.654Z</updated>
    
    <content type="html"><![CDATA[<p>CAS，Compare and set。是Java中实现原子操作的重要手段，在Java并发工具中起着重要作用。</p><p><img src="/Wiki/wiki/Java/CAS/201703090001_thumb.png" alt="201703090001"></p><h1 id="CAS是什么"><a href="#CAS是什么" class="headerlink" title="CAS是什么"></a>CAS是什么</h1><p>CAS是一种多线程同步中常用的原子操作。在CAS中，有三个重要的参数：<strong>内存值V、旧的预期值A、要更新成为的值B</strong>，当且仅当内存值V等于旧的预期值A时，才把内存值V更改成B。基于CAS操作，可以实现乐观锁机制，乐观锁的思想是认为数据一般情况下不会发生冲突，所以在数据<strong>提交更新</strong>的时候，才会对冲突进行检测。乐观锁是种思想，而CAS是这种思想的一种实现方式。注意，CAS是一种操作，CAS一般配合自旋来实现乐观锁机制。</p><p>让我们以<strong>AtomicInteger</strong>为例来看看CAS的应用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> jdk.internal.misc.Unsafe U = jdk.internal.misc.Unsafe.getUnsafe();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> VALUE = U.objectFieldOffset(AtomicInteger.class, <span class="string">"value"</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">addAndGet</span><span class="params">(<span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> U.getAndAddInt(<span class="keyword">this</span>, VALUE, delta) + delta;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，VALUE是变量值在内存中的地址，delta是在原值基础上要加的值。</p><p>调用<strong>unsafe</strong>的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        v = getIntVolatile(o, offset);</span><br><span class="line">    &#125; <span class="keyword">while</span> (!weakCompareAndSetInt(o, offset, v, v + delta));</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">weakCompareAndSetInt</span><span class="params">(Object o, <span class="keyword">long</span> offset,</span></span></span><br><span class="line"><span class="function"><span class="params">                                              <span class="keyword">int</span> expected,</span></span></span><br><span class="line"><span class="function"><span class="params">                                              <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> compareAndSetInt(o, offset, expected, x);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>其中，<code>getIntVolatile</code> 和<code>compareAndSetInt</code>都是调用的native方法，从<code>getIntVolatile</code>可以看出利用CAS进行不断<strong>重试</strong>，注意，CAS只是一次操作，native方法<code>compareAndSetInt</code>的四个参数：<strong>对象、对象的地址、预期值和修改值。</strong></p><h1 id="CAS缺点"><a href="#CAS缺点" class="headerlink" title="CAS缺点"></a>CAS缺点</h1><h2 id="竞争激烈时开销大"><a href="#竞争激烈时开销大" class="headerlink" title="竞争激烈时开销大"></a>竞争激烈时开销大</h2><p>在竞争激励时，CAS失败的概率比较大，如果循环CAS，则可能出现CAS长时间不成功会给CPU带来非常大的执行开销。</p><h2 id="只能实现一个共享变量的原子操作"><a href="#只能实现一个共享变量的原子操作" class="headerlink" title="只能实现一个共享变量的原子操作"></a>只能实现一个共享变量的原子操作</h2><p>可以使用AtomicReference类来保证引用对象的原子性，把多个变量放在一个对象里进行CAS操作。</p><h2 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h2><p>ABA问题即，如果一个值原来是A，中间变成了B，后来又变成了A。这时候CAS检查时会认为没有发生变化。这就是ABA问题。ABA问题会带来什么隐患呢。</p><h3 id="ABA隐患"><a href="#ABA隐患" class="headerlink" title="ABA隐患"></a>ABA隐患</h3><p>在Java这种垃圾回收型的语言中，可以避免一种比较典型的ABA问题。以C++为例</p><blockquote><p>A common case of the ABA problem is encountered when implementing a <a href="http://en.wikipedia.org/wiki/Lock-free" rel="external nofollow noopener noreferrer" target="_blank">lock-free</a> data structure. If an item is removed from the list, deleted, and then a new item is allocated and added to the list, it is common for the allocated object to be at the same location as the deleted object due to optimization. A pointer to the new item is thus sometimes equal to a pointer to the old item which is an ABA problem.</p></blockquote><p>C++中，对指针进行CAS操作，即使两个指针相同，它们也未必指向同一个对象。有可能是第一个指针所指向的内存被释放后，第二个对象恰好分配在相同地址的内存。</p><p>而在GC环境中，两个引用相等，其指向对对象必然相等，因为只要对象存在引用，其对象的内存就不会被回收掉，那么新new出来的对象地址也不可能重复。</p><p>当然，Java中也存在ABA问题，在链表结构中容易出现。</p><p>如下例子：</p><p>线程1准备用CAS将变量的值由A替换为B，在此之前，线程2将变量的值由A替换为C，又由C替换为A，然后线程1执行CAS时发现变量的值仍然为A，所以CAS成功。但实际上这时的现场已经和最初不同了，尽管CAS成功，但可能存在潜藏的问题，例如下面的例子：</p><p><img src="/Wiki/wiki/Java/CAS/2156552600.png" alt="2156552600"></p><p>现有一个用单向链表实现的堆栈，栈顶为A，这时线程T1已经知道A.next为B，然后希望用CAS将栈顶替换为B：</p><p><code>head.compareAndSet(A,B)</code></p><p>在T1执行上面这条指令之前，线程T2介入，将A、B出栈，再pushD、C、A，此时堆栈结构如下图，而对象B此时处于游离状态：</p><p><img src="/Wiki/wiki/Java/CAS/2333354197.png" alt="ABA-2.png"></p><p>此时轮到线程T1执行CAS操作，检测发现栈顶仍为A，所以CAS成功，栈顶变为B，但实际上B.next为null，所以此时的情况变为：</p><p><img src="/Wiki/wiki/Java/CAS/1281662470.png" alt="ABA-3.png"></p><p>其中堆栈中只有B一个元素，C和D组成的链表不再存在于堆栈中，平白无故就把C、D丢掉了。</p><h3 id="ABA问题解决"><a href="#ABA问题解决" class="headerlink" title="ABA问题解决"></a>ABA问题解决</h3><p>ABA问题可以通过版本号进行解决，利用AtomicStampedReference可以解决 这个问题，<code>AtomicStampedReference</code>主要维护包含一个对象引用以及一个可以自动更新的整数”stamp”的pair对象来解决ABA问题。</p><h1 id="利用CAS实现线程安全的单例"><a href="#利用CAS实现线程安全的单例" class="headerlink" title="利用CAS实现线程安全的单例"></a>利用CAS实现线程安全的单例</h1><p>不使用synchronized和lock，如何实现一个线程安全的单例？可以利用CAS。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicReference&lt;Singleton&gt; INSTANCE = <span class="keyword">new</span> AtomicReference&lt;Singleton&gt;(); </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Singleton singleton = INSTANCE.get();</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != singleton) &#123;</span><br><span class="line">                <span class="keyword">return</span> singleton;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">            <span class="keyword">if</span> (INSTANCE.compareAndSet(<span class="keyword">null</span>, singleton)) &#123;</span><br><span class="line">                <span class="keyword">return</span> singleton;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;CAS，Compare and set。是Java中实现原子操作的重要手段，在Java并发工具中起着重要作用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/Wiki/wiki/Java/CAS/201703090001_thumb.png&quot; alt=&quot;201703090001&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="Java" scheme="http://polyval.github.io/Wiki/categories/Java/"/>
    
    
      <category term="Java" scheme="http://polyval.github.io/Wiki/tags/Java/"/>
    
      <category term="并发" scheme="http://polyval.github.io/Wiki/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Linux命令</title>
    <link href="http://polyval.github.io/Wiki/wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux%E5%91%BD%E4%BB%A4/"/>
    <id>http://polyval.github.io/Wiki/wiki/操作系统/Linux命令/</id>
    <published>2018-10-21T05:08:29.000Z</published>
    <updated>2018-10-23T14:27:06.632Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h1><p><code>ps -ef | grep &quot;&quot;</code></p><h1 id="zgrep"><a href="#zgrep" class="headerlink" title="zgrep"></a>zgrep</h1><h1 id="xargs"><a href="#xargs" class="headerlink" title="xargs"></a>xargs</h1><h1 id="find"><a href="#find" class="headerlink" title="find"></a>find</h1><p><code>find . -name &quot;&quot; | xargs zgrep &quot;&quot;</code></p><h1 id="查找端口被占用的程序"><a href="#查找端口被占用的程序" class="headerlink" title="查找端口被占用的程序"></a>查找端口被占用的程序</h1><p><code>lsof -i :&lt;port&gt;</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ps&quot;&gt;&lt;a href=&quot;#ps&quot; class=&quot;headerlink&quot; title=&quot;ps&quot;&gt;&lt;/a&gt;ps&lt;/h1&gt;&lt;p&gt;&lt;code&gt;ps -ef | grep &amp;quot;&amp;quot;&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&quot;zgrep&quot;&gt;&lt;a href=&quot;#z
      
    
    </summary>
    
      <category term="操作系统" scheme="http://polyval.github.io/Wiki/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>Java分析工具</title>
    <link href="http://polyval.github.io/Wiki/wiki/Java/Java%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/"/>
    <id>http://polyval.github.io/Wiki/wiki/Java/Java分析工具/</id>
    <published>2018-10-21T03:28:21.000Z</published>
    <updated>2018-10-22T04:32:23.553Z</updated>
    
    <content type="html"><![CDATA[<h1 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h1><h2 id="输出对象实例个数"><a href="#输出对象实例个数" class="headerlink" title="输出对象实例个数"></a>输出对象实例个数</h2><p><code>jmap -histo &lt;pid&gt; &gt; a.log</code></p><p>查看应用代码实例的个数，对于出现内存泄露的情况，可以快速定位出是哪个对象引起的。</p><h2 id="输出堆文件"><a href="#输出堆文件" class="headerlink" title="输出堆文件"></a>输出堆文件</h2><p><code>jmap -dump:format=b,file = a.dat &lt;pid&gt;</code></p><h2 id="查看进程堆内存使用情况"><a href="#查看进程堆内存使用情况" class="headerlink" title="查看进程堆内存使用情况"></a>查看进程堆内存使用情况</h2><p><code>jmap -heap &lt;pid&gt;</code></p><h1 id="jhat"><a href="#jhat" class="headerlink" title="jhat"></a>jhat</h1><h4 id="查看dump文件"><a href="#查看dump文件" class="headerlink" title="查看dump文件"></a>查看dump文件</h4><p><code>jhat -port 9998 /tmp/var/dump.dat</code></p><p>然后在浏览器中输入localhost:9998即可查看</p><h1 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h1><h1 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h1><h2 id="监控GC"><a href="#监控GC" class="headerlink" title="监控GC"></a>监控GC</h2><p><code>jstat -gcutil  &lt;pid&gt; &lt;interval&gt; &lt;count&gt;</code></p><h1 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h1><p>输出JVM中运行的进程状态信息</p><h1 id="jConsole"><a href="#jConsole" class="headerlink" title="jConsole"></a>jConsole</h1><h1 id="jinfo"><a href="#jinfo" class="headerlink" title="jinfo"></a>jinfo</h1><h1 id="jVisualvm"><a href="#jVisualvm" class="headerlink" title="jVisualvm"></a>jVisualvm</h1><h1 id="eclipse-memory-analyzer"><a href="#eclipse-memory-analyzer" class="headerlink" title="eclipse memory analyzer"></a>eclipse memory analyzer</h1><p>dump分析工具</p><h1 id="Btrace"><a href="#Btrace" class="headerlink" title="Btrace"></a>Btrace</h1><h1 id="Greys-Anatomy"><a href="#Greys-Anatomy" class="headerlink" title="Greys-Anatomy"></a><a href="https://github.com/oldmanpushcart/greys-anatomy" rel="external nofollow noopener noreferrer" target="_blank">Greys-Anatomy</a></h1><p>在线问题诊断工具</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;jmap&quot;&gt;&lt;a href=&quot;#jmap&quot; class=&quot;headerlink&quot; title=&quot;jmap&quot;&gt;&lt;/a&gt;jmap&lt;/h1&gt;&lt;h2 id=&quot;输出对象实例个数&quot;&gt;&lt;a href=&quot;#输出对象实例个数&quot; class=&quot;headerlink&quot; title=&quot;输
      
    
    </summary>
    
      <category term="Java" scheme="http://polyval.github.io/Wiki/categories/Java/"/>
    
    
      <category term="Java" scheme="http://polyval.github.io/Wiki/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>CAP定理</title>
    <link href="http://polyval.github.io/Wiki/wiki/%E5%88%86%E5%B8%83%E5%BC%8F/CAP%E5%AE%9A%E7%90%86/"/>
    <id>http://polyval.github.io/Wiki/wiki/分布式/CAP定理/</id>
    <published>2018-10-21T03:28:21.000Z</published>
    <updated>2018-10-21T03:58:02.665Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CAP定理"><a href="#CAP定理" class="headerlink" title="CAP定理"></a>CAP定理</h2><p>分布式系统中有三个指标</p><ul><li>Consistency 一致性</li><li>Avaliability 可用性</li><li>Partition tolerance 分区容错</li></ul><p>CAP定理认为这三个指标不可能同时做到。</p><h2 id="Patition-tolerance"><a href="#Patition-tolerance" class="headerlink" title="Patition tolerance"></a>Patition tolerance</h2><p>分区容错指分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务。</p><h2 id="Consistency"><a href="#Consistency" class="headerlink" title="Consistency"></a>Consistency</h2><p>等同于所有节点访问同一份最新的数据副本</p><h2 id="Avaliability"><a href="#Avaliability" class="headerlink" title="Avaliability"></a>Avaliability</h2><p>可用性指“<code>Reads and writes always succeed</code>”，即服务一直可用，而且是正常响应时间。</p><h2 id="CAP权衡"><a href="#CAP权衡" class="headerlink" title="CAP权衡"></a>CAP权衡</h2><p>CAP权衡有三种情况</p><h3 id="CA-without-P"><a href="#CA-without-P" class="headerlink" title="CA without P"></a>CA without P</h3><p>这种情况在分布式系统中几乎是不存在的。首先在分布式环境下，网络分区是一个自然的事实。因为分区是必然的，所以如果舍弃P，意味着要舍弃分布式系统。那也就没有必要再讨论CAP理论了。    </p><p>对于一个分布式系统来说。P是一个基本要求，CAP三者中，只能在CA两者之间做权衡，并且要想尽办法提升P。</p><h3 id="CP-without-A"><a href="#CP-without-A" class="headerlink" title="CP without A"></a>CP without A</h3><p>如果一个分布式系统不要求强的可用性，即容许系统停机或者长时间无响应的话，就可以在CAP三者中保障CP而舍弃A。</p><p>一个保证了CP而一个舍弃了A的分布式系统，一旦发生网络故障或者消息丢失等情况，就要牺牲用户的体验，等待所有数据全部一致了之后再让用户访问系统。</p><h3 id="AP-wihtout-C"><a href="#AP-wihtout-C" class="headerlink" title="AP wihtout C"></a>AP wihtout C</h3><p>要高可用并允许分区，则需放弃一致性。一旦网络问题发生，节点之间可能会失去联系。为了保证高可用，需要在用户访问时可以马上得到返回，则每个节点只能用本地数据提供服务，而这样会导致全局数据的不一致性。</p><p>这种舍弃强一致性而保证系统的分区容错性和可用性的场景和案例非常多。前面我们介绍可用性的时候说到过，很多系统在可用性方面会做很多事情来保证系统的全年可用性可以达到N个9，所以，对于很多业务系统来说，比如淘宝的购物，12306的买票。都是在可用性和一致性之间舍弃了一致性而选择可用性。</p><p>你在12306买票的时候肯定遇到过这种场景，当你购买的时候提示你是有票的（但是可能实际已经没票了），你也正常的去输入验证码，下单了。但是过了一会系统提示你下单失败，余票不足。这其实就是先在可用性方面保证系统可以正常的服务，然后在数据的一致性方面做了些牺牲，会影响一些用户体验，但是也不至于造成用户流程的严重阻塞。</p><p>但是，我们说很多网站牺牲了一致性，选择了可用性，这其实也不准确的。就比如上面的买票的例子，其实舍弃的只是<strong>强一致性</strong>。退而求其次保证了<strong>最终一致性</strong>。也就是说，虽然下单的瞬间，关于车票的库存可能存在数据不一致的情况，但是过了一段时间，还是要保证最终一致性的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;CAP定理&quot;&gt;&lt;a href=&quot;#CAP定理&quot; class=&quot;headerlink&quot; title=&quot;CAP定理&quot;&gt;&lt;/a&gt;CAP定理&lt;/h2&gt;&lt;p&gt;分布式系统中有三个指标&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Consistency 一致性&lt;/li&gt;
&lt;li&gt;Avaliabi
      
    
    </summary>
    
      <category term="分布式" scheme="http://polyval.github.io/Wiki/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="分布式" scheme="http://polyval.github.io/Wiki/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>AQS</title>
    <link href="http://polyval.github.io/Wiki/wiki/Java/AQS/"/>
    <id>http://polyval.github.io/Wiki/wiki/Java/AQS/</id>
    <published>2018-10-21T03:28:21.000Z</published>
    <updated>2018-11-02T03:23:41.033Z</updated>
    
    <content type="html"><![CDATA[<p><strong>AbstractQueuedSynchronizer</strong>是一个抽象类，为Java中各种<strong>Synchronizers</strong>(<strong>同步器</strong>)的实现提供了一个模版框架。</p><h1 id="Synchronizers是什么？"><a href="#Synchronizers是什么？" class="headerlink" title="Synchronizers是什么？"></a>Synchronizers是什么？</h1><p>Synchronizers是实现多线程通信、同步的工具和手段。如锁、Semaphore、阻塞队列、CyclicBarrier、CountDownLatch等。同步器通常包含如下几个部分来实现多线程同步</p><ul><li>状态（state）</li><li>访问控制（access control）</li><li>状态转化（state change）</li><li>通知策略（Notification Strategy）</li><li>Test and Set方法</li><li>Set方法</li></ul><p>当然，不是所有同步器都需要这些东西，有些同步器也可能通过其他方式来实现同步。</p><p><strong>访问控制</strong>利用同步器的同步<strong>状态</strong>来决定线程是否可以进入临界区(发生竞争的代码段)。线程进入后，改变<strong>状态</strong>，从而阻塞(可能)其他线程。有时候，当一个线程改变状态后，可能需要<strong>通知</strong>其他线程状态发生了改变。这几个过程如下两个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lock</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> isLocked = <span class="keyword">false</span>; <span class="comment">// state</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">    <span class="comment">// access control</span></span><br><span class="line">    <span class="keyword">while</span>(isLocked)&#123; <span class="comment">// </span></span><br><span class="line">      <span class="comment">//wait strategy - related to notification strategy</span></span><br><span class="line">      wait();</span><br><span class="line">    &#125;</span><br><span class="line">    isLocked = <span class="keyword">true</span>; <span class="comment">// state change</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>&#123;</span><br><span class="line">    isLocked = <span class="keyword">false</span>;</span><br><span class="line">    notify(); <span class="comment">//notification strategy</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BoundedSemaphore</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> signals = <span class="number">0</span>; <span class="comment">// state</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> bound   = <span class="number">0</span>; <span class="comment">// state</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">BoundedSemaphore</span><span class="params">(<span class="keyword">int</span> upperBound)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.bound = upperBound;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">    <span class="comment">// access control</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">this</span>.signals == bound) wait();</span><br><span class="line">    <span class="comment">//state change</span></span><br><span class="line">    <span class="keyword">this</span>.signals++;</span><br><span class="line">    <span class="keyword">this</span>.notify();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">this</span>.signals == <span class="number">0</span>) wait();</span><br><span class="line">    <span class="comment">//state change</span></span><br><span class="line">    <span class="keyword">this</span>.signals--;</span><br><span class="line">    <span class="keyword">this</span>.notify(); <span class="comment">// notification strategy</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="同步器最重要的两类方法"><a href="#同步器最重要的两类方法" class="headerlink" title="同步器最重要的两类方法"></a>同步器最重要的两类方法</h2><p>同步器最重要的两类方法是：acquire和release方法。acquire方法阻塞调用这个方法的线程直到同步状态满足访问控制要求，release方法改变同步状态，这个同步状态的改变有可能使得一个或多个阻塞线程恢复。</p><p>acquire的逻辑如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">while (当前同步状态不允许进行acquire) &#123;</span><br><span class="line"></span><br><span class="line">如果当前线程不在队列则将其加入队列；</span><br><span class="line"></span><br><span class="line">有可能阻塞当前线程；</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">如果当前线程在队列中则出队列</span><br></pre></td></tr></table></figure></p><p>release的逻辑如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">更新同步状态</span><br><span class="line">if (同步状态有可能使某些阻塞线程acquire)</span><br><span class="line">去阻塞这些线程</span><br></pre></td></tr></table></figure><p>具体参考<a href="http://tutorials.jenkov.com/java-concurrency/anatomy-of-a-synchronizer.html" rel="external nofollow noopener noreferrer" target="_blank">synchronizer</a>，<a href="http://gee.cs.oswego.edu/dl/papers/aqs.pdf" rel="external nofollow noopener noreferrer" target="_blank">Doug Lea的论文</a></p><h1 id="AQS提供的功能"><a href="#AQS提供的功能" class="headerlink" title="AQS提供的功能"></a>AQS提供的功能</h1><p>作为一个框架，AQS主要提供了对<strong>同步状态的原子操作</strong>、<strong>阻塞与唤醒线程</strong>、<strong>队列管理线程等功能</strong>，在上一节我们知道了我们需要对同步状态进行改变，这个改变需要保证原子性，通过同步状态来实现访问控制，从而实现线程的阻塞与唤醒。</p><h2 id="同步状态"><a href="#同步状态" class="headerlink" title="同步状态"></a>同步状态</h2><p>AQS中通过一个带volatile语义的int变量来维护同步状态。提供<strong>getState</strong>、<strong>setState</strong>和<strong>compareAndSetState</strong>方法来访问和更新状态，AQS的具体实现类需要根据这些方法来实现<code>tryAcquire</code>和<code>tryRelease</code>方法。</p><h2 id="阻塞-Blocking"><a href="#阻塞-Blocking" class="headerlink" title="阻塞(Blocking)"></a>阻塞(Blocking)</h2><p>java.util.concurrent.locks提供了LockSupport类来实现线程的阻塞与唤醒。</p><p><code>LockSupport.park</code>阻塞线程，<code>LockSupport.unpark</code>唤醒线程。</p><h2 id="同步队列"><a href="#同步队列" class="headerlink" title="同步队列"></a>同步队列</h2><p>同步队列用来维护线程队列，它是一个FIFO队列。来完成线程获取锁的排队工作。</p><h2 id="Condition队列"><a href="#Condition队列" class="headerlink" title="Condition队列"></a>Condition队列</h2><p>等待队列，通过内部ConditionObject构成，当Condition调用await()方法后，线程将会加入等待队列中，而当Condition调用signal()方法后，线程将从等待队列转移动同步队列中进行锁竞争。Condition提供的方法类似于Object对象的监视器方法wait()、notify()和notifyAll()。关于Condition，参考</p><h1 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h1><p>同步队列是一个FIFO双向队列，在该队列中，一个Node节点表示一个线程。</p><h2 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h2><p>每个线程用一个Node表示。Node有个重要的字段<strong>waitStatus</strong>，表示节点线程的状态。其值含义如下：</p><ul><li>SIGNAL，表示当前节点的后继节点处于或即将处于阻塞状态，当前节点在release或者cancel的时候需要唤醒后继节点</li><li>CANCELLED，表示当前节点线程由于超时或者中断而被取消</li><li>CONDITION，表示当前节点在条件队列中，节点线程等待在Condition上，当其他线程对Condition调用了signal()后，改节点将会从条件队列中转移到同步队列中，加入到同步状态的获取中</li><li>PROPAGATE，在共享模式下，后续节点传播唤醒的操作。</li><li>默认值</li></ul><p>除了<strong>waitStatus</strong>，Node还保存了线程的引用、前驱节点、后继节点和条件队列中用到的下一节点(nextWaiter)。其中，还有两个静态变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Marker to indicate a node is waiting in shared mode */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line"><span class="comment">/** Marker to indicate a node is waiting in exclusive mode */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><h3 id="共享模式和独占模式是什么意思？"><a href="#共享模式和独占模式是什么意思？" class="headerlink" title="共享模式和独占模式是什么意思？"></a>共享模式和独占模式是什么意思？</h3><p>共享模式指的是允许多个线程获取同一个锁而且可能获取成功，独占模式指的是一个锁如果被一个线程持有，其他线程必须等待。</p><p>同步队列结构图如下：</p><p><img src="/Wiki/wiki/Java/AQS/6222919-5b6f37fd54f6f00b.png" alt=""></p><p>我们先来看看独占模式下的<code>acquire</code>和<code>release</code>两个重要方法。</p><h2 id="acquire"><a href="#acquire" class="headerlink" title="acquire"></a>acquire</h2><p>acquire的流程图如下</p><p><img src="/Wiki/wiki/Java/AQS/19151122_tpXi.jpg" alt="è¾å¥å¾çè¯´æ"></p><p>acquire方法是AQS提供的模版方法，其中tryAcquire方法由子类来实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>tryAcquire</code>，由子类实现，去尝试获取锁</li><li><code>addWaiter</code>，创建一个新节点加入到队尾</li><li><code>acquireQueued</code>，如果前驱节点为头节点，循环去获取锁，否则线程等待。</li></ul><p>我们来看一下三个线程同时去争取锁的时候发生了什么。</p><p>首先，<code>tryAcquire</code>中，一般是通过CAS来实现对锁的竞争，这三个线程其中一个CAS成功，另外两个失败。它们的<code>tryAcquire</code>返回false；</p><p><code>addWaiter</code>方法将这两个失败的线程以EXCLUSIVE类型节点加入同步队列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="comment">// 如果队尾节点不为null</span></span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 直接CAS入队尾</span></span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 队尾为空或者CAS失败</span></span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先判断是否存在尾节点，如果存在，则CAS将新生成的节点设置为尾节点。如果CAS失败或者尾节点不存在，则用enq将其加入尾节点，总之，<code>addWaiter</code>就是将创建新节点加入到队尾。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="comment">// 尾节点不存在，需要初始化</span></span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 尾节点有了</span></span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里两个线程进入，其中一个线程发现尾节点为空，则CAS生成尾节点，另外一个节点CAS失败或者在if时就判断尾节点生成了，直接将自己设成尾节点即可。</p><p><code>acquireQueued</code>方法大概过程如下：</p><p>对于同时进入的线程2和线程3，对于线程2前一个节点为头节点，会再尝试获取锁一次，如果失败，则将头节点的waitStatus改成SIGNAL，下次循环的时候会再次去尝试获取锁，如果还是失败，其waitStatus为SIGNAL，则通过LockSupport将线程挂起；对于线程3，由于它的前驱节点为线程2，根据FIFO，需要等至少线程2获取到锁3才去获取锁，因此3只需将2点waitStatus改成SIGNAL，然后再检查一下自己是否有资格去获取锁，没有则挂起。</p><p><strong>这里有个问题，这个FIFO顺序是否就实现了公平锁呢？</strong></p><p>让我们看看线程1释放锁后这个锁是怎么传递到。</p><h2 id="release"><a href="#release" class="headerlink" title="release"></a>release</h2><p>线程1在释放锁的时候的操作如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 唤醒后继节点</span></span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>tryRelease</code>同样由子类来实现，在<code>tryRelease</code>中，1会释放掉锁。会将state从1改成0，此时，如果线程4来了，那么这个锁就有可能被4给拿去而不是依次从2到3，因此上节中的问题，FIFO同步队列并不能保证锁的公平获取，它只能保证入了队列的线程获取锁的一个先后顺序，这也是为什么<strong>ReentrantLock</strong>中需要实现公平锁的逻辑。</p><p>当1释放锁后，判断队列中是否有节点，如果有节点，则去通知节点来拿锁。unparkSuccessor主要做三件事情：</p><ol><li>将队头的waitStatus设置为0.</li><li>通过从队列尾部向队列头部移动，找到最后一个waitStatus&lt;=0的那个节点，也就是离队头最近的没有被cancelled的那个节点，队头这个时候指向这个节点。</li><li>将这个节点唤醒，这个时候线程1已经出队列了。</li></ol><h2 id="acquireShared"><a href="#acquireShared" class="headerlink" title="acquireShared"></a>acquireShared</h2><p>共享模式与独占模式acquire逻辑大致相同，区别在于入队列后获取锁成功后的操作，如果获取锁成功，共享模式会判断后继节点是否是共享模式，如果是，则立即对其进行唤醒操作。</p><h2 id="releaseShared"><a href="#releaseShared" class="headerlink" title="releaseShared"></a>releaseShared</h2><p>共享模式下的release逻辑也是要保证释放锁的时候往后传播，使得所有共享模式的节点都可以被唤醒。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Ensure that a release propagates, even if there are other</span></span><br><span class="line"><span class="comment">     * in-progress acquires/releases.  This proceeds in the usual</span></span><br><span class="line"><span class="comment">     * way of trying to unparkSuccessor of head if it needs</span></span><br><span class="line"><span class="comment">     * signal. But if it does not, status is set to PROPAGATE to</span></span><br><span class="line"><span class="comment">     * ensure that upon release, propagation continues.</span></span><br><span class="line"><span class="comment">     * Additionally, we must loop in case a new node is added</span></span><br><span class="line"><span class="comment">     * while we are doing this. Also, unlike other uses of</span></span><br><span class="line"><span class="comment">     * unparkSuccessor, we need to know if CAS to reset status</span></span><br><span class="line"><span class="comment">     * fails, if so rechecking.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;AbstractQueuedSynchronizer&lt;/strong&gt;是一个抽象类，为Java中各种&lt;strong&gt;Synchronizers&lt;/strong&gt;(&lt;strong&gt;同步器&lt;/strong&gt;)的实现提供了一个模版框架。&lt;/p&gt;
&lt;h1 id=&quot;S
      
    
    </summary>
    
      <category term="Java" scheme="http://polyval.github.io/Wiki/categories/Java/"/>
    
    
      <category term="Java" scheme="http://polyval.github.io/Wiki/tags/Java/"/>
    
      <category term="并发" scheme="http://polyval.github.io/Wiki/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Git</title>
    <link href="http://polyval.github.io/Wiki/wiki/%E5%B7%A5%E5%85%B7/Git/"/>
    <id>http://polyval.github.io/Wiki/wiki/工具/Git/</id>
    <published>2018-10-21T03:28:21.000Z</published>
    <updated>2018-10-21T05:06:54.216Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><h2 id="四大区"><a href="#四大区" class="headerlink" title="四大区"></a>四大区</h2><ul><li>工作区(Working Directory)</li><li>暂存区(Stage or index)</li><li>本地库</li><li>远程库</li></ul><p>各区的转换图如下</p><p><img src="/Wiki/wiki/工具/Git/git-reset_drbfhd.png" alt="Imagem de capa"></p><h2 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h2><p>HEAD是一个特殊的指针，指向当前工作分支的最新commit</p><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><h2 id="cherry-pick"><a href="#cherry-pick" class="headerlink" title="cherry-pick"></a>cherry-pick</h2><p>再次应用已经存在的commits，可以将其他分支的某些commit应用到当前分支。</p><h3 id="git-cherry-pick-lt-commit-id-gt"><a href="#git-cherry-pick-lt-commit-id-gt" class="headerlink" title="git cherry-pick &lt;commit id&gt;"></a><code>git cherry-pick &lt;commit id&gt;</code></h3><h3 id="git-cherry-pick-lt-start-commit-id-gt-lt-end-commit-id-gt"><a href="#git-cherry-pick-lt-start-commit-id-gt-lt-end-commit-id-gt" class="headerlink" title="git cherry-pick &lt;start-commit-id&gt;^..&lt;end-commit-id&gt;"></a><code>git cherry-pick &lt;start-commit-id&gt;^..&lt;end-commit-id&gt;</code></h3><p>应用这一区段的commits，左闭右闭。</p><h3 id="git-cherry-pick-abort"><a href="#git-cherry-pick-abort" class="headerlink" title="git cherry-pick --abort"></a><code>git cherry-pick --abort</code></h3><p>取消操作</p><h2 id="stash"><a href="#stash" class="headerlink" title="stash"></a>stash</h2><p>在某些分支上进行了改动，但是还没有完成，也没有提交，这个时候又要切到另外一个分支上进行工作。</p><h3 id="git-stash"><a href="#git-stash" class="headerlink" title="git stash"></a><code>git stash</code></h3><h3 id="git-stash-list"><a href="#git-stash-list" class="headerlink" title="git stash list"></a><code>git stash list</code></h3><h3 id="git-stash-apply"><a href="#git-stash-apply" class="headerlink" title="git stash apply"></a><code>git stash apply</code></h3><p>恢复到上次stash的状态</p><h3 id="git-stash-pop"><a href="#git-stash-pop" class="headerlink" title="git stash pop"></a><code>git stash pop</code></h3><p>恢复到上次stash的状态并去掉上次的stash</p><h2 id="revert"><a href="#revert" class="headerlink" title="revert"></a>revert</h2><p>将某些commit回退掉，同时会生成新的commit来记录这次操作</p><h3 id="git-revert-lt-commit-gt"><a href="#git-revert-lt-commit-gt" class="headerlink" title="git revert &lt;commit&gt;"></a><code>git revert &lt;commit&gt;</code></h3><h3 id="git-revert-HEAD-3"><a href="#git-revert-HEAD-3" class="headerlink" title="git revert HEAD~3"></a><code>git revert HEAD~3</code></h3><p>撤销倒数第四次commit。</p><h2 id="reset"><a href="#reset" class="headerlink" title="reset"></a>reset</h2><h3 id="三种模式"><a href="#三种模式" class="headerlink" title="三种模式"></a>三种模式</h3><ul><li>– mixed。回退暂存区，工作区不动。也就是说改动的文件不会动但是会回退到未提交状态。—mixed是默认选项。</li><li>– hard。 暂存区和工作区都会被回退掉。</li><li>– soft。 暂存区和工作区都不会动，回退到指定的commit之后，这个commit之后的文件都处于changed to be committed状态。</li></ul><h3 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a><code>git reset</code></h3><p>git add 之后想撤销就可以用这个命令</p><h3 id="git-reset-hard-HEAD-3"><a href="#git-reset-hard-HEAD-3" class="headerlink" title="git reset --hard HEAD~3"></a><code>git reset --hard HEAD~3</code></h3><p>最近三次提交不想要了，也不想再看到它们。可以使用这个命令。</p><h3 id="git-reset-lt-file-gt"><a href="#git-reset-lt-file-gt" class="headerlink" title="git reset -- &lt;file&gt;"></a><code>git reset -- &lt;file&gt;</code></h3><p>回退单个文件。</p><h2 id="reflog"><a href="#reflog" class="headerlink" title="reflog"></a>reflog</h2><p>ref + log</p><p>reflog命令可以查看所有的历史操作记录</p><p>比如误操作用了<code>git reset --hard HEAD^</code></p><p>这时候用<code>git log</code>是找不到原来的commit的，这时候可以用<code>git reflog</code>找到commit id来进行恢复。</p><h2 id="rebase"><a href="#rebase" class="headerlink" title="rebase"></a>rebase</h2><p>将某个分支的修改移动到当前分支，依次将提交作用到当前分支，作用到过程中生成新的提交记录，提交信息默认与原来的一致。</p><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h1&gt;&lt;h2 id=&quot;四大区&quot;&gt;&lt;a href=&quot;#四大区&quot; class=&quot;headerlink&quot; title=&quot;四大区&quot;&gt;&lt;/a&gt;四大区&lt;/h2&gt;&lt;u
      
    
    </summary>
    
      <category term="工具" scheme="http://polyval.github.io/Wiki/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>Spring Cloud</title>
    <link href="http://polyval.github.io/Wiki/wiki/%E5%BE%AE%E6%9C%8D%E5%8A%A1/Spring%20Cloud/"/>
    <id>http://polyval.github.io/Wiki/wiki/微服务/Spring Cloud/</id>
    <published>2018-10-21T03:28:21.000Z</published>
    <updated>2018-10-21T03:58:14.321Z</updated>
    
    <content type="html"><![CDATA[<h2 id="配置管理"><a href="#配置管理" class="headerlink" title="配置管理"></a>配置管理</h2><h2 id="服务治理"><a href="#服务治理" class="headerlink" title="服务治理"></a>服务治理</h2><h3 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h3><p>服务向注册中心登记自己提供的服务</p><h3 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h3><p>通过服务名发起请求调用</p><h2 id="断路器"><a href="#断路器" class="headerlink" title="断路器"></a>断路器</h2><h2 id="智能路由"><a href="#智能路由" class="headerlink" title="智能路由"></a>智能路由</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;配置管理&quot;&gt;&lt;a href=&quot;#配置管理&quot; class=&quot;headerlink&quot; title=&quot;配置管理&quot;&gt;&lt;/a&gt;配置管理&lt;/h2&gt;&lt;h2 id=&quot;服务治理&quot;&gt;&lt;a href=&quot;#服务治理&quot; class=&quot;headerlink&quot; title=&quot;服务治理&quot;&gt;&lt;/a
      
    
    </summary>
    
      <category term="微服务" scheme="http://polyval.github.io/Wiki/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
      <category term="微服务" scheme="http://polyval.github.io/Wiki/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>Java内存优化</title>
    <link href="http://polyval.github.io/Wiki/wiki/Java/Java%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/"/>
    <id>http://polyval.github.io/Wiki/wiki/Java/Java内存优化/</id>
    <published>2018-10-21T03:28:21.000Z</published>
    <updated>2018-10-29T04:35:10.386Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常驻内存"><a href="#常驻内存" class="headerlink" title="常驻内存"></a>常驻内存</h1><h2 id="排查内存泄漏"><a href="#排查内存泄漏" class="headerlink" title="排查内存泄漏"></a>排查内存泄漏</h2><h2 id="重用对象"><a href="#重用对象" class="headerlink" title="重用对象"></a>重用对象</h2><h3 id="String-intern"><a href="#String-intern" class="headerlink" title="String.intern()"></a>String.intern()</h3><p>在某服务中，通过与其他进程通讯获取到格式为byte[]的字段，将byte[]转化成String的时候利用new String(byte[])方法，但是string很多是相同的，产生了大量相同的string对象，而且这些对象是程序中当作缓存来用一直存在于内存中，采用String.intern()对String对象进行缓存，降低了内存占用30M。</p><h2 id="Integer-valueOf"><a href="#Integer-valueOf" class="headerlink" title="Integer.valueOf()"></a>Integer.valueOf()</h2><h3 id="只需一个实例的对象一定要使用单例"><a href="#只需一个实例的对象一定要使用单例" class="headerlink" title="只需一个实例的对象一定要使用单例"></a>只需一个实例的对象一定要使用单例</h3><h3 id="对象池技术"><a href="#对象池技术" class="headerlink" title="对象池技术"></a>对象池技术</h3><h2 id="使用小数据类型"><a href="#使用小数据类型" class="headerlink" title="使用小数据类型"></a>使用小数据类型</h2><h2 id="减少线程数"><a href="#减少线程数" class="headerlink" title="减少线程数"></a>减少线程数</h2><h2 id="去垃圾回收机制"><a href="#去垃圾回收机制" class="headerlink" title="去垃圾回收机制"></a>去垃圾回收机制</h2><h2 id="System-arraycopy"><a href="#System-arraycopy" class="headerlink" title="System.arraycopy ()"></a>System.arraycopy ()</h2><h1 id="临时内存"><a href="#临时内存" class="headerlink" title="临时内存"></a>临时内存</h1><h2 id="减少不必要的对象拷贝，重写对象的clone方法"><a href="#减少不必要的对象拷贝，重写对象的clone方法" class="headerlink" title="减少不必要的对象拷贝，重写对象的clone方法"></a>减少不必要的对象拷贝，重写对象的clone方法</h2><h2 id="容器大小预估"><a href="#容器大小预估" class="headerlink" title="容器大小预估"></a>容器大小预估</h2><p>容器在扩容时会产生大量临时对象，对容器大小进行预估传入初始值可以减少容器的扩容</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;常驻内存&quot;&gt;&lt;a href=&quot;#常驻内存&quot; class=&quot;headerlink&quot; title=&quot;常驻内存&quot;&gt;&lt;/a&gt;常驻内存&lt;/h1&gt;&lt;h2 id=&quot;排查内存泄漏&quot;&gt;&lt;a href=&quot;#排查内存泄漏&quot; class=&quot;headerlink&quot; title=&quot;排查内存泄
      
    
    </summary>
    
      <category term="Java" scheme="http://polyval.github.io/Wiki/categories/Java/"/>
    
    
      <category term="Java" scheme="http://polyval.github.io/Wiki/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>CPU占用过高定位</title>
    <link href="http://polyval.github.io/Wiki/wiki/Java/CPU%E5%8D%A0%E7%94%A8%E8%BF%87%E9%AB%98%E5%AE%9A%E4%BD%8D/"/>
    <id>http://polyval.github.io/Wiki/wiki/Java/CPU占用过高定位/</id>
    <published>2018-10-06T16:28:21.000Z</published>
    <updated>2018-10-11T04:44:09.302Z</updated>
    
    <content type="html"><![CDATA[<h2 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h2><h3 id="找到CPU占用过高的线程"><a href="#找到CPU占用过高的线程" class="headerlink" title="找到CPU占用过高的线程"></a>找到CPU占用过高的线程</h3><p><code>top -p &lt;pid&gt;</code></p><p>输入H查看该进程的所有线程的统计情况，从而找到CPU占用过高的线程；</p><p>将线程id转化为16进制就是Java堆栈中对应的nid</p><h3 id="查看Java堆栈"><a href="#查看Java堆栈" class="headerlink" title="查看Java堆栈"></a>查看Java堆栈</h3><p><a href="http://0000-bigtree.github.io/blog/2017/03/05/get-java-process-stack.html" rel="external nofollow noopener noreferrer" target="_blank">获取Java堆栈</a></p><p>在线程堆栈中找到nid=上一步nid的线程堆栈</p><h4 id="找到对应的线程id"><a href="#找到对应的线程id" class="headerlink" title="找到对应的线程id"></a>找到对应的线程id</h4><ul><li><p>如果该线程正在执行Java代码，说明是该Java代码导致的CPU高</p></li><li><p>如果线程在执行native code，说明是本地代码导致的CPU高。通过<code>pstack pid</code>获取本地线程堆栈，在本地线程堆栈中找到对应线程，借助本地线程堆栈进行定位。</p></li></ul><h4 id="找不到对应的线程id"><a href="#找不到对应的线程id" class="headerlink" title="找不到对应的线程id"></a>找不到对应的线程id</h4><p>有两种可能</p><h5 id="虚拟机自身代码导致的"><a href="#虚拟机自身代码导致的" class="headerlink" title="虚拟机自身代码导致的"></a>虚拟机自身代码导致的</h5><p>如堆内存枯竭导致的频繁Full GC，或者虚拟机的bug。此时可以通过本地线程堆栈进行定位。</p><h5 id="重新创建了线程来执行"><a href="#重新创建了线程来执行" class="headerlink" title="重新创建了线程来执行"></a>重新创建了线程来执行</h5><h2 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h2><p>多次打印线程堆栈，找到相同的代码段</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;方法1&quot;&gt;&lt;a href=&quot;#方法1&quot; class=&quot;headerlink&quot; title=&quot;方法1&quot;&gt;&lt;/a&gt;方法1&lt;/h2&gt;&lt;h3 id=&quot;找到CPU占用过高的线程&quot;&gt;&lt;a href=&quot;#找到CPU占用过高的线程&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="Java" scheme="http://polyval.github.io/Wiki/categories/Java/"/>
    
    
      <category term="Java" scheme="http://polyval.github.io/Wiki/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java内存溢出的情况</title>
    <link href="http://polyval.github.io/Wiki/wiki/Java/Java%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E7%9A%84%E6%83%85%E5%86%B5/"/>
    <id>http://polyval.github.io/Wiki/wiki/Java/Java内存溢出的情况/</id>
    <published>2018-10-06T16:28:21.000Z</published>
    <updated>2018-10-11T04:52:43.709Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、java-lang-OutOfMemoryError-Java-heap-space"><a href="#1、java-lang-OutOfMemoryError-Java-heap-space" class="headerlink" title="1、java.lang.OutOfMemoryError:Java heap space"></a>1、<code>java.lang.OutOfMemoryError:Java heap space</code></h3><p>Java应用程序在启动时会指定所需要的内存大小，它被分割成两个不同的区域：<code>Heap space（堆空间）</code>和<code>Permgen（永久代）</code>：</p><p>JVM内存模型示意图</p><p> 这两个区域的大小可以在JVM（Java虚拟机）启动时通过参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xmx</span><br></pre></td></tr></table></figure><p>和</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:MaxPermSize</span><br></pre></td></tr></table></figure><p>设置，如果你没有显式设置，则将使用特定平台的默认值。</p><p>当应用程序试图向堆空间添加更多的数据，但堆却没有足够的空间来容纳这些数据时，将会触发<code>java.lang.OutOfMemoryError: Java heap space</code>异常。需要注意的是：即使有足够的物理内存可用，只要达到堆空间设置的大小限制，此异常仍然会被触发。</p><h4 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h4><p>触发<code>java.lang.OutOfMemoryError: Java heap space</code>最常见的原因就是应用程序需要的堆空间是XXL号的，但是JVM提供的却是S号。解决方法也很简单，提供更大的堆空间即可。除了前面的因素还有更复杂的成因：</p><ul><li>流量/数据量峰值：应用程序在设计之初均有用户量和数据量的限制，某一时刻，当用户数量或数据量突然达到一个峰值，并且这个峰值已经超过了设计之初预期的阈值，那么以前正常的功能将会停止，并触发<code>java.lang.OutOfMemoryError: Java heap space</code>异常。</li><li>内存泄漏：特定的编程错误会导致你的应用程序不停的消耗更多的内存，每次使用有内存泄漏风险的功能就会留下一些不能被回收的对象到堆空间中，随着时间的推移，泄漏的对象会消耗所有的堆空间，最终触发<code>java.lang.OutOfMemoryError: Java heap space</code>错误。</li></ul><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><h5 id="①、简单示例"><a href="#①、简单示例" class="headerlink" title="①、简单示例"></a>①、简单示例</h5><p>首先看一个非常简单的示例，下面的代码试图创建2 x 1024 x 1024个元素的整型数组，当你尝试编译并指定12M堆空间运行时（java -Xmx12m OOM）将会失败并抛出<code>java.lang.OutOfMemoryError: Java heap space</code>错误，而当你指定13M堆空间时，将正常的运行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class OOM &#123;</span><br><span class="line">    static final int SIZE=2*1024*1024;</span><br><span class="line">    public static void main(String[] a) &#123;</span><br><span class="line">        int[] i = new int[SIZE];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">D:\&gt;javac OOM.java</span><br><span class="line">D:\&gt;java -Xmx12m OOM</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">        at OOM.main(OOM.java:4)</span><br><span class="line">D:\&gt;java -Xmx13m OOM</span><br></pre></td></tr></table></figure><h5 id="②、内存泄漏示例"><a href="#②、内存泄漏示例" class="headerlink" title="②、内存泄漏示例"></a>②、内存泄漏示例</h5><p>在Java中，当开发者创建一个新对象（比如：<code>new Integer(5)</code>）时，不需要自己开辟内存空间，而是把它交给JVM。在应用程序整个生命周期类，JVM负责检查哪些对象可用，哪些对象未被使用。未使用对象将被丢弃，其占用的内存也将被回收，这一过程被称为垃圾回收。JVM负责垃圾回收的模块集合被称为垃圾回收器（<code>GC</code>）。</p><p>Java的内存自动管理机制依赖于GC定期查找未使用对象并删除它们。Java中的内存泄漏是由于GC无法识别一些已经不再使用的对象，而这些未使用的对象一直留在堆空间中，这种堆积最终会导致<code>java.lang.OutOfMemoryError: Java heap space</code>错误。</p><p>我们可以非常容易的写出导致内存泄漏的Java代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class KeylessEntry &#123;</span><br><span class="line">    </span><br><span class="line">    static class Key &#123;</span><br><span class="line">        Integer id;</span><br><span class="line">        </span><br><span class="line">        Key(Integer id) &#123;</span><br><span class="line">            this.id = id;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        @Override</span><br><span class="line">        public int hashCode() &#123;</span><br><span class="line">            return id.hashCode();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Map&lt;Key,String&gt; m = new HashMap&lt;Key,String&gt;();</span><br><span class="line">        while(true) &#123;</span><br><span class="line">            for(int i=0;i&lt;10000;i++) &#123;</span><br><span class="line">                if(!m.containsKey(new Key(i))) &#123;</span><br><span class="line">                    m.put(new Key(i), &quot;Number:&quot; + i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中<code>HashMap</code>为本地缓存，第一次while循环，会将10000个元素添加到缓存中。后面的while循环中，由于key已经存在于缓存中，缓存的大小将一直会维持在10000。但事实真的如此吗？由于<code>Key</code>实体没有实现<code>equals()</code>方法，导致for循环中每次执行<code>m.containsKey(new Key(i))</code>结果均为<code>false</code>，其结果就是<code>HashMap</code>中的元素将一直增加。</p><p>随着时间的推移，越来越多的<code>Key</code>对象进入堆空间且不能被垃圾收集器回收（m为局部变量，GC会认为这些对象一直可用，所以不会回收），直到所有的堆空间被占用，最后抛出<code>java.lang.OutOfMemoryError:Java heap space</code>。</p><blockquote><p>上面的代码直接运行可能很久也不会抛出异常，可以在启动时使用-Xmx参数，设置堆内存大小，或者在for循环后打印HashMap的大小，执行后会发现HashMap的size一直再增长。</p></blockquote><p>解决方法也非常简单，只要<code>Key</code>实现自己的<code>equals</code>方法即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Override</span><br><span class="line">public boolean equals(Object o) &#123;</span><br><span class="line">    boolean response = false;</span><br><span class="line">    if (o instanceof Key) &#123;</span><br><span class="line">        response = (((Key)o).id).equals(this.id);</span><br><span class="line">    &#125;</span><br><span class="line">    return response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>第一个解决方案是显而易见的，你应该确保有足够的堆空间来正常运行你的应用程序，在JVM的启动配置中增加如下配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xmx1024m</span><br></pre></td></tr></table></figure><p>上面的配置分配1024M堆空间给你的应用程序，当然你也可以使用其他单位，比如用G表示GB，K表示KB。下面的示例都表示最大堆空间为1GB：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java -Xmx1073741824 com.mycompany.MyClass</span><br><span class="line">java -Xmx1048576k com.mycompany.MyClass</span><br><span class="line">java -Xmx1024m com.mycompany.MyClass</span><br><span class="line">java -Xmx1g com.mycompany.MyClass</span><br></pre></td></tr></table></figure><p>然后，更多的时候，单纯地增加堆空间不能解决所有的问题。如果你的程序存在内存泄漏，一味的增加堆空间也只是推迟<code>java.lang.OutOfMemoryError: Java heap space</code>错误出现的时间而已，并未解决这个隐患。除此之外，垃圾收集器在GC时，应用程序会停止运行直到GC完成，而增加堆空间也会导致GC时间延长，进而影响程序的吞吐量。</p><p>如果你想完全解决这个问题，那就好好提升自己的编程技能吧，当然运用好<code>Debuggers, profilers, heap dump analyzers</code>等工具，可以让你的程序最大程度的避免内存泄漏问题。</p><h3 id="2、java-lang-OutOfMemoryError-GC-overhead-limit-exceeded"><a href="#2、java-lang-OutOfMemoryError-GC-overhead-limit-exceeded" class="headerlink" title="2、java.lang.OutOfMemoryError:GC overhead limit exceeded"></a>2、<code>java.lang.OutOfMemoryError:GC overhead limit exceeded</code></h3><p>默认情况下，当应用程序花费超过98%的时间用来做GC并且回收了不到2%的堆内存时，会抛出<code>java.lang.OutOfMemoryError:GC overhead limit exceeded</code>错误。具体的表现就是你的应用几乎耗尽所有可用内存，并且GC多次均未能清理干净。</p><h4 id="原因分析-1"><a href="#原因分析-1" class="headerlink" title="原因分析"></a>原因分析</h4><p><code>java.lang.OutOfMemoryError:GC overhead limit exceeded</code>错误是一个信号，示意你的应用程序在垃圾收集上花费了太多时间但却没有什么卵用。默认超过98%的时间用来做GC却回收了不到2%的内存时将会抛出此错误。那如果没有此限制会发生什么呢？GC进程将被重启，100%的CPU将用于GC，而没有CPU资源用于其他正常的工作。如果一个工作本来只需要几毫秒即可完成，现在却需要几分钟才能完成，我想这种结果谁都没有办法接受。</p><p>所以<code>java.lang.OutOfMemoryError:GC overhead limit exceeded</code>也可以看做是一个<code>fail-fast（快速失败）</code>实战的实例。</p><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><p>下面的代码初始化一个<code>map</code>并在无限循环中不停的添加键值对，运行后将会抛出<code>GC overhead limit exceeded</code>错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Wrapper &#123;</span><br><span class="line">    public static void main(String args[]) throws Exception &#123;</span><br><span class="line">        Map map = System.getProperties();</span><br><span class="line">        Random r = new Random();</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            map.put(r.nextInt(), &quot;value&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们使用如下参数启动程序时：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Xmx100m -XX:+UseParallelGC Wrapper</span><br></pre></td></tr></table></figure><p>我们很快就可以看到程序抛出<code>java.lang.OutOfMemoryError: GC overhead limit exceeded</code>错误。但如果在启动时设置不同的堆空间大小或者使用不同的GC算法，比如这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Xmx10m -XX:+UseParallelGC Wrapper</span><br></pre></td></tr></table></figure><p>我们将看到如下错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">    at java.util.Hashtable.rehash(Unknown Source)</span><br><span class="line">    at java.util.Hashtable.addEntry(Unknown Source)</span><br><span class="line">    at java.util.Hashtable.put(Unknown Source)</span><br><span class="line">    at cn.moondev.Wrapper.main(Wrapper.java:12)</span><br></pre></td></tr></table></figure><p>使用以下GC算法：<code>-XX:+UseConcMarkSweepGC</code> 或者<code>-XX:+UseG1GC</code>，启动命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java -Xmx100m -XX:+UseConcMarkSweepGC Wrapper</span><br><span class="line">java -Xmx100m -XX:+UseG1GC Wrapper</span><br></pre></td></tr></table></figure><p>得到的结果是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Exception: java.lang.OutOfMemoryError thrown from </span><br><span class="line">the UncaughtExceptionHandler in thread &quot;main&quot;</span><br></pre></td></tr></table></figure><p>错误已经被默认的异常处理程序捕获，并且没有任何错误的堆栈信息输出。</p><p>以上这些变化可以说明，在资源有限的情况下，你根本无法无法预测你的应用是怎样挂掉的，什么时候会挂掉，所以在开发时，你不能仅仅保证自己的应用程序在特定的环境下正常运行。</p><h4 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h4><p>首先是一个毫无诚意的解决方案，如果你仅仅是不想看到<code>java.lang.OutOfMemoryError:GC overhead limit exceeded</code>的错误信息，可以在应用程序启动时添加如下JVM参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:-UseGCOverheadLimit</span><br></pre></td></tr></table></figure><p>但是强烈建议不要使用这个选项，因为这样并没有解决任何问题，只是推迟了错误出现的时间，错误信息也变成了我们更熟悉的<code>java.lang.OutOfMemoryError: Java heap space</code>而已。</p><p>另一个解决方案，如果你的应用程序确实内存不足，增加堆内存会解决<code>GC overhead limit</code>问题，就如下面这样，给你的应用程序1G的堆内存：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Xmx1024m com.yourcompany.YourClass</span><br></pre></td></tr></table></figure><p>但如果你想确保你已经解决了潜在的问题，而不是掩盖<code>java.lang.OutOfMemoryError: GC overhead limit exceeded</code>错误，那么你不应该仅止步于此。你要记得还有<code>profilers</code>和<code>memory dump analyzers</code>这些工具，你需要花费更多的时间和精力来查找问题。还有一点需要注意，这些工具在Java运行时有显著的开销，因此不建议在生产环境中使用。</p><h3 id="3、java-lang-OutOfMemoryError-Permgen-space"><a href="#3、java-lang-OutOfMemoryError-Permgen-space" class="headerlink" title="3、java.lang.OutOfMemoryError:Permgen space"></a>3、<code>java.lang.OutOfMemoryError:Permgen space</code></h3><p>Java中堆空间是JVM管理的最大一块内存空间，可以在JVM启动时指定堆空间的大小，其中堆被划分成两个不同的区域：新生代（Young）和老年代（Tenured），新生代又被划分为3个区域：<code>Eden</code>、<code>From Survivor</code>、<code>To Survivor</code></p><p><code>java.lang.OutOfMemoryError: PermGen space</code>错误就表明持久代所在区域的内存已被耗尽。</p><h4 id="原因分析-2"><a href="#原因分析-2" class="headerlink" title="原因分析"></a>原因分析</h4><p>要理解<code>java.lang.OutOfMemoryError: PermGen space</code>出现的原因，首先需要理解<code>Permanent Generation Space</code>的用处是什么。持久代主要存储的是每个类的信息，比如：<strong>类加载器引用</strong>、<strong>运行时常量池（所有常量、字段引用、方法引用、属性）</strong>、<strong>字段(Field)数据</strong>、<strong>方法(Method)数据</strong>、<strong>方法代码</strong>、<strong>方法字节码</strong>等等。我们可以推断出，<code>PermGen</code>的大小取决于被加载类的数量以及类的大小。</p><p>因此，我们可以得出出现<code>java.lang.OutOfMemoryError: PermGen space</code>错误的原因是：太多的类或者太大的类被加载到<code>permanent generation</code>（持久代）。</p><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><h5 id="①、最简单的示例"><a href="#①、最简单的示例" class="headerlink" title="①、最简单的示例"></a>①、最简单的示例</h5><p>正如前面所描述的，<code>PermGen</code>的使用与加载到JVM类的数量有密切关系，下面是一个最简单的示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import javassist.ClassPool;</span><br><span class="line">public class MicroGenerator &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        for (int i = 0; i &lt; 100_000_000; i++) &#123;</span><br><span class="line">            generate(&quot;cn.moondev.User&quot; + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Class generate(String name) throws Exception &#123;</span><br><span class="line">        ClassPool pool = ClassPool.getDefault();</span><br><span class="line">        return pool.makeClass(name).toClass();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行时请设置JVM参数：<code>-XX:MaxPermSize=5m</code>，值越小越好。需要注意的是JDK8已经完全移除持久代空间，取而代之的是元空间（<code>Metaspace</code>），所以示例最好的JDK1.7或者1.6下运行。</p><p>代码在运行时不停的生成类并加载到持久代中，直到撑满持久代内存空间，最后抛出<code>java.lang.OutOfMemoryError:Permgen space</code>。代码中类的生成使用了<code>javassist</code>库。</p><h5 id="②、Redeploy-time"><a href="#②、Redeploy-time" class="headerlink" title="②、Redeploy-time"></a>②、Redeploy-time</h5><p>更复杂和实际的一个例子就是Redeploy（重新部署，你可以想象一下你开发时，点击eclipse的reploy按钮或者使用idea时按ctrl + F5时的过程）。在从服务器卸载应用程序时，当前的<code>classloader</code>以及加载的<code>class</code>在没有实例引用的情况下，持久代的内存空间会被GC清理并回收。如果应用中有类的实例对当前的<code>classloader</code>的引用，那么<code>Permgen</code>区的<code>class</code>将无法被卸载，导致<code>Permgen</code>区的内存一直增加直到出现<code>Permgen space</code>错误。</p><p>不幸的是，许多第三方库以及糟糕的资源处理方式（比如：线程、JDBC驱动程序、文件系统句柄）使得卸载以前使用的类加载器变成了一件不可能的事。反过来就意味着在每次重新部署过程中，应用程序所有的类的先前版本将仍然驻留在<code>Permgen</code>区中，你的每次部署都将生成几十甚至几百M的垃圾。</p><p>就以线程和JDBC驱动来说说。很多人都会使用线程来处理一下周期性或者耗时较长的任务，这个时候一定要注意线程的生命周期问题，你需要确保线程不能比你的应用程序活得还长。否则，如果应用程序已经被卸载，线程还在继续运行，这个线程通常会维持对应用程序的<code>classloader</code>的引用，造成的结果就不再多说。多说一句，<strong>开发者有责任处理好这个问题，特别是如果你是第三方库的提供者的话，一定要提供线程关闭接口来处理清理工作</strong>。</p><p>让我们想象一个使用JDBC驱动程序连接到关系数据库的示例应用程序。当应用程序部署到服务器上的时：服务器创建一个<code>classloader</code>实例来加载应用所有的类（包含相应的JDBC驱动）。根据JDBC规范，JDBC驱动程序（比如：<code>com.mysql.jdbc.Driver</code>）会在初始化时将自己注册到<code>java.sql.DriverManager</code>中。该注册过程中会将驱动程序的一个实例存储在DriverManager的静态字段内，代码可以参考：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// com.mysql.jdbc.Driver源码</span><br><span class="line">package com.mysql.jdbc;</span><br><span class="line"></span><br><span class="line">public class Driver extends NonRegisteringDriver implements java.sql.Driver &#123;</span><br><span class="line">    public Driver() throws SQLException &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            DriverManager.registerDriver(new Driver());</span><br><span class="line">        &#125; catch (SQLException var1) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;Can\&apos;t register driver!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// // // // // // // // // //</span><br><span class="line">// 再看下DriverManager对应代码</span><br><span class="line">private final static CopyOnWriteArrayList&lt;DriverInfo&gt; registeredDrivers = new CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">public static synchronized void registerDriver(java.sql.Driver driver,DriverAction da) throws SQLException &#123;</span><br><span class="line">    if(driver != null) &#123;</span><br><span class="line">        registeredDrivers.addIfAbsent(new DriverInfo(driver, da));</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，当从服务器上卸载应用程序的时候，<code>java.sql.DriverManager</code>仍将持有那个驱动程序的引用，进而持有用于加载应用程序的<code>classloader</code>的一个实例的引用。这个<code>classloader</code>现在仍然引用着应用程序的所有类。如果此程序启动时需要加载2000个类，占用约10MB永久代（PermGen）内存，那么只需要5~10次重新部署，就会将默认大小的永久代（PermGen）塞满，然后就会触发<code>java.lang.OutOfMemoryError: PermGen space</code>错误并崩溃。</p><h4 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h4><h5 id="①-解决初始化时的OutOfMemoryError"><a href="#①-解决初始化时的OutOfMemoryError" class="headerlink" title="① 解决初始化时的OutOfMemoryError"></a>① 解决初始化时的<code>OutOfMemoryError</code></h5><p>当在应用程序启动期间触发由于<code>PermGen</code>耗尽引起的<code>OutOfMemoryError</code>时，解决方案很简单。 应用程序需要更多的空间来加载所有的类到<code>PermGen</code>区域，所以我们只需要增加它的大小。 为此，请更改应用程序启动配置，并添加（或增加，如果存在）-XX：MaxPermSize参数，类似于以下示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -XX:MaxPermSize=512m com.yourcompany.YourClass</span><br></pre></td></tr></table></figure><h5 id="②-解决Redeploy时的OutOfMemoryError"><a href="#②-解决Redeploy时的OutOfMemoryError" class="headerlink" title="② 解决Redeploy时的OutOfMemoryError"></a>② 解决<code>Redeploy</code>时的<code>OutOfMemoryError</code></h5><p>分析dump文件：首先，找出引用在哪里被持有；其次，给你的web应用程序添加一个关闭的hook，或者在应用程序卸载后移除引用。你可以使用如下命令导出dump文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -dump:format=b,file=dump.hprof &lt;process-id&gt;</span><br></pre></td></tr></table></figure><p>如果是你自己代码的问题请及时修改，如果是第三方库，请试着搜索一下是否存在”关闭”接口，如果没有给开发者提交一个bug或者issue吧。</p><h5 id="③-解决运行时OutOfMemoryError"><a href="#③-解决运行时OutOfMemoryError" class="headerlink" title="③ 解决运行时OutOfMemoryError"></a>③ 解决运行时<code>OutOfMemoryError</code></h5><p>首先你需要检查是否允许GC从<code>PermGen</code>卸载类，JVM的标准配置相当保守，只要类一创建，即使已经没有实例引用它们，其仍将保留在内存中，特别是当应用程序需要动态创建大量的类但其生命周期并不长时，允许JVM卸载类对应用大有助益，你可以通过在启动脚本中添加以下配置参数来实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+CMSClassUnloadingEnabled</span><br></pre></td></tr></table></figure><p>默认情况下，这个配置是未启用的，如果你启用它，GC将扫描<code>PermGen</code>区并清理已经不再使用的类。但请注意，这个配置只在<code>UseConcMarkSweepGC</code>的情况下生效，如果你使用其他GC算法，比如：<code>ParallelGC</code>或者<code>Serial GC</code>时，这个配置无效。所以使用以上配置时，请配合：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseConcMarkSweepGC</span><br></pre></td></tr></table></figure><p>如果你已经确保JVM可以卸载类，但是仍然出现内存溢出问题，那么你应该继续分析dump文件，使用以下命令生成dump文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -dump:file=dump.hprof,format=b &lt;process-id&gt;</span><br></pre></td></tr></table></figure><p>当你拿到生成的堆转储文件，并利用像Eclipse Memory Analyzer Toolkit这样的工具来寻找应该卸载却没被卸载的类加载器，然后对该类加载器加载的类进行排查，找到可疑对象，分析使用或者生成这些类的代码，查找产生问题的根源并解决它。</p><h3 id="4、java-lang-OutOfMemoryError-Metaspace"><a href="#4、java-lang-OutOfMemoryError-Metaspace" class="headerlink" title="4、java.lang.OutOfMemoryError:Metaspace"></a>4、<code>java.lang.OutOfMemoryError:Metaspace</code></h3><p>前文已经提过，<code>PermGen</code>区域用于存储类的名称和字段，类的方法，方法的字节码，常量池，JIT优化等，但从Java8开始，Java中的内存模型发生了重大变化：引入了称为<code>Metaspace</code>的新内存区域，而删除了<code>PermGen</code>区域。请注意：不是简单的将<code>PermGen</code>区所存储的内容直接移到<code>Metaspace</code>区，<code>PermGen</code>区中的某些部分，已经移动到了普通堆里面。</p><h4 id="原因分析-3"><a href="#原因分析-3" class="headerlink" title="原因分析"></a>原因分析</h4><p>Java8做出如此改变的原因包括但不限于：</p><ul><li>应用程序所需要的<code>PermGen</code>区大小很难预测，设置太小会触发<code>PermGen OutOfMemoryError</code>错误，过度设置导致资源浪费。</li><li>提升GC性能，在HotSpot中的每个垃圾收集器需要专门的代码来处理存储在<code>PermGen</code>中的类的元数据信息。从<code>PermGen</code>分离类的元数据信息到<code>Metaspace</code>，由于<code>Metaspace</code>的分配具有和<code>Java Heap</code>相同的地址空间，因此<code>Metaspace</code>和<code>Java Heap</code>可以无缝的管理，而且简化了<code>FullGC</code>的过程，以至将来可以并行的对元数据信息进行垃圾收集，而没有GC暂停。</li><li>支持进一步优化，比如：G1并发类的卸载，也算为将来做准备吧</li></ul><p>正如你所看到的，元空间大小的要求取决于加载的类的数量以及这种类声明的大小。 所以很容易看到<code>java.lang.OutOfMemoryError: Metaspace</code>主要原因：太多的类或太大的类加载到元空间。</p><h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h4><p>正如上文中所解释的，元空间的使用与加载到JVM中的类的数量密切相关。 下面的代码是最简单的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Metaspace &#123;</span><br><span class="line">    static javassist.ClassPool cp = javassist.ClassPool.getDefault();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception&#123;</span><br><span class="line">        for (int i = 0; ; i++) &#123; </span><br><span class="line">            Class c = cp.makeClass(&quot;eu.plumbr.demo.Generated&quot; + i).toClass();</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序运行中不停的生成新类，所有的这些类的定义将被加载到<code>Metaspace</code>区，直到空间被完全占用并且抛出<code>java.lang.OutOfMemoryError:Metaspace</code>。当使用<code>-XX：MaxMetaspaceSize = 32m</code>启动时，大约加载30000多个类时就会死机。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">31023</span><br><span class="line">31024</span><br><span class="line">Exception in thread &quot;main&quot; javassist.CannotCompileException: by java.lang.OutOfMemoryError: Metaspace</span><br><span class="line">    at javassist.ClassPool.toClass(ClassPool.java:1170)</span><br><span class="line">    at javassist.ClassPool.toClass(ClassPool.java:1113)</span><br><span class="line">    at javassist.ClassPool.toClass(ClassPool.java:1071)</span><br><span class="line">    at javassist.CtClass.toClass(CtClass.java:1275)</span><br><span class="line">    at cn.moondev.book.Metaspace.main(Metaspace.java:12)</span><br><span class="line">    .....</span><br></pre></td></tr></table></figure><h4 id="解决方案-3"><a href="#解决方案-3" class="headerlink" title="解决方案"></a>解决方案</h4><p>第一个解决方案是显而易见的，既然应用程序会耗尽内存中的<code>Metaspace</code>区空间，那么应该增加其大小，更改启动配置增加如下参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 告诉JVM：Metaspace允许增长到512，然后才能抛出异常</span><br><span class="line">-XX：MaxMetaspaceSize = 512m</span><br></pre></td></tr></table></figure><p>另一个方法就是删除此参数来完全解除对<code>Metaspace</code>大小的限制（默认是没有限制的）。默认情况下，对于64位服务器端JVM，MetaspaceSize默认大小是21M（初始限制值），一旦达到这个限制值，FullGC将被触发进行类卸载，并且这个限制值将会被重置，新的限制值依赖于<code>Metaspace</code>的剩余容量。如果没有足够空间被释放，这个限制值将会上升，反之亦然。在技术上<code>Metaspace</code>的尺寸可以增长到交换空间，而这个时候本地内存分配将会失败（更具体的分析，可以参考：<a href="https://link.jianshu.com?t=http%3A%2F%2Fifeve.com%2Fjava-permgen-removed%2F" rel="external nofollow noopener noreferrer" target="_blank">Java PermGen 去哪里了?</a>）。</p><p>你可以通过修改各种启动参数来“快速修复”这些内存溢出错误，但你需要正确区分你是否只是推迟或者隐藏了<code>java.lang.OutOfMemoryError</code>的症状。如果你的应用程序确实存在内存泄漏或者本来就加载了一些不合理的类，那么所有这些配置都只是推迟问题出现的时间而已，实际也不会改善任何东西。</p><h3 id="5、java-lang-OutOfMemoryError-Unable-to-create-new-native-thread"><a href="#5、java-lang-OutOfMemoryError-Unable-to-create-new-native-thread" class="headerlink" title="5、java.lang.OutOfMemoryError:Unable to create new native thread"></a>5、<code>java.lang.OutOfMemoryError:Unable to create new native thread</code></h3><p>一个思考线程的方法是将线程看着是执行任务的工人，如果你只有一个工人，那么他同时只能执行一项任务，但如果你有十几个工人，就可以同时完成你几个任务。就像这些工人都在物理世界，JVM中的线程完成自己的工作也是需要一些空间的</p><p>出现<code>java.lang.OutOfMemoryError:Unable to create new native thread</code>就意味着Java应用程序已达到其可以启动线程数量的极限了。</p><h4 id="原因分析-4"><a href="#原因分析-4" class="headerlink" title="原因分析"></a>原因分析</h4><p>当JVM向OS请求创建一个新线程时，而OS却无法创建新的native线程时就会抛出<code>Unable to create new native thread</code>错误。一台服务器可以创建的线程数依赖于物理配置和平台，建议运行下文中的示例代码来测试找出这些限制。总体上来说，抛出此错误会经过以下几个阶段：</p><ul><li>运行在JVM内的应用程序请求创建一个新的线程</li><li>JVM向OS请求创建一个新的native线程</li><li>OS尝试创建一个新的native线程，这时需要分配内存给新的线程</li><li>OS拒绝分配内存给线程，因为32位Java进程已经耗尽内存地址空间（2-4GB内存地址已被命中）或者OS的虚拟内存已经完全耗尽</li><li><code>Unable to create new native thread</code>错误将被抛出</li></ul><h4 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h4><p>下面的示例不能的创建并启动新的线程。当代码运行时，很快达到OS的线程数限制，并抛出<code>Unable to create new native thread</code>错误。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">while(true)&#123;</span><br><span class="line">    new Thread(new Runnable()&#123;</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(10000000);</span><br><span class="line">            &#125; catch(InterruptedException e) &#123; &#125;        </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解决方案-4"><a href="#解决方案-4" class="headerlink" title="解决方案"></a>解决方案</h4><p>有时，你可以通过在OS级别增加线程数限制来绕过这个错误。如果你限制了JVM可在用户空间创建的线程数，那么你可以检查并增加这个限制：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// macOS 10.12上执行</span><br><span class="line">$ ulimit -u</span><br><span class="line">709</span><br></pre></td></tr></table></figure><p>当你的应用程序产生成千上万的线程，并抛出此异常，表示你的程序已经出现了很严重的编程错误，我不觉得应该通过修改参数来解决这个问题，不管是OS级别的参数还是JVM启动参数。更可取的办法是分析你的应用是否真的需要创建如此多的线程来完成任务？是否可以使用线程池或者说线程池的数量是否合适？是否可以更合理的拆分业务来实现…..</p><h3 id="6、java-lang-OutOfMemoryError-Out-of-swap-space"><a href="#6、java-lang-OutOfMemoryError-Out-of-swap-space" class="headerlink" title="6、java.lang.OutOfMemoryError:Out of swap space?"></a>6、<code>java.lang.OutOfMemoryError:Out of swap space?</code></h3><p>Java应用程序在启动时会指定所需要的内存大小，可以通过<code>-Xmx</code>和其他类似的启动参数来指定。在JVM请求的总内存大于可用物理内存的情况下，操作系统会将内存中的数据交换到磁盘上去。</p><p><code>Out of swap space?</code>表示交换空间也将耗尽，并且由于缺少物理内存和交换空间，再次尝试分配内存也将失败。</p><h4 id="原因分析-5"><a href="#原因分析-5" class="headerlink" title="原因分析"></a>原因分析</h4><p>当应用程序向JVM native heap请求分配内存失败并且native heap也即将耗尽时，JVM会抛出<code>Out of swap space</code>错误。该错误消息中包含分配失败的大小（以字节为单位）和请求失败的原因。</p><blockquote><p>Native Heap Memory是JVM内部使用的Memory，这部分的Memory可以通过JDK提供的JNI的方式去访问，这部分Memory效率很高，但是管理需要自己去做，如果没有把握最好不要使用，以防出现内存泄露问题。JVM 使用Native Heap Memory用来优化代码载入（JTI代码生成），临时对象空间申请，以及JVM内部的一些操作。</p></blockquote><p>这个问题往往发生在Java进程已经开始交换的情况下，现代的GC算法已经做得足够好了，当时当面临由于交换引起的延迟问题时，GC暂停的时间往往会让大多数应用程序不能容忍。</p><p><code>java.lang.OutOfMemoryError:Out of swap space?</code>往往是由操作系统级别的问题引起的，例如：</p><ul><li>操作系统配置的交换空间不足。</li><li>系统上的另一个进程消耗所有内存资源。</li></ul><p>还有可能是本地内存泄漏导致应用程序失败，比如：应用程序调用了native code连续分配内存，但却没有被释放。</p><h4 id="解决方案-5"><a href="#解决方案-5" class="headerlink" title="解决方案"></a>解决方案</h4><p>解决这个问题有几个办法，通常最简单的方法就是增加交换空间，不同平台实现的方式会有所不同，比如在Linux下可以通过如下命令实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 原作者使用，由于我手里并没有Linux环境，所以并未测试</span><br><span class="line"># 创建并附加一个大小为640MB的新交换文件</span><br><span class="line">swapoff -a </span><br><span class="line">dd if=/dev/zero of=swapfile bs=1024 count=655360</span><br><span class="line">mkswap swapfile</span><br><span class="line">swapon swapfile</span><br></pre></td></tr></table></figure><p>Java GC会扫描内存中的数据，如果是对交换空间运行垃圾回收算法会使GC暂停的时间增加几个数量级，因此你应该慎重考虑使用上文增加交换空间的方法。</p><p>如果你的应用程序部署在JVM需要同其他进程激烈竞争获取资源的物理机上，建议将服务隔离到单独的虚拟机中</p><p>但在许多情况下，您唯一真正可行的替代方案是：</p><ul><li>升级机器以包含更多内存</li><li>优化应用程序以减少其内存占用</li></ul><p>当您转向优化路径时，使用内存转储分析程序来检测内存中的大分配是一个好的开始。</p><h3 id="7、java-lang-OutOfMemoryError-Requested-array-size-exceeds-VM-limit"><a href="#7、java-lang-OutOfMemoryError-Requested-array-size-exceeds-VM-limit" class="headerlink" title="7、java.lang.OutOfMemoryError:Requested array size exceeds VM limit"></a>7、<code>java.lang.OutOfMemoryError:Requested array size exceeds VM limit</code></h3><p>Java对应用程序可以分配的最大数组大小有限制。不同平台限制有所不同，但通常在1到21亿个元素之间。</p><p>当你遇到<code>Requested array size exceeds VM limit</code>错误时，意味着你的应用程序试图分配大于Java虚拟机可以支持的数组。</p><h4 id="原因分析-6"><a href="#原因分析-6" class="headerlink" title="原因分析"></a>原因分析</h4><p>该错误由JVM中的<code>native code</code>抛出。 JVM在为数组分配内存之前，会执行特定于平台的检查：分配的数据结构是否在此平台中是可寻址的。</p><p>你很少见到这个错误是因为Java数组的索引是int类型。 Java中的最大正整数为2 ^ 31 - 1 = 2,147,483,647。 并且平台特定的限制可以非常接近这个数字，例如：我的环境上(64位macOS，运行Jdk1.8)可以初始化数组的长度高达2,147,483,645（Integer.MAX_VALUE-2）。如果再将数组的长度增加1到Integer.MAX_VALUE-1会导致熟悉的OutOfMemoryError：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Requested array size exceeds VM limit</span><br></pre></td></tr></table></figure><p>但是，在使用OpenJDK 6的32位Linux上，在分配具有大约11亿个元素的数组时，您将遇到<code>Requested array size exceeded VM limit</code>的错误。 要理解你的特定环境的限制，运行下文中描述的小测试程序。</p><h4 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 3; i &gt;= 0; i--) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        int[] arr = new int[Integer.MAX_VALUE-i];</span><br><span class="line">        System.out.format(&quot;Successfully initialized an array with %,d elements.\n&quot;, Integer.MAX_VALUE-i);</span><br><span class="line">    &#125; catch (Throwable t) &#123;</span><br><span class="line">        t.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该示例重复四次，并在每个回合中初始化一个长原语数组。 该程序尝试初始化的数组的大小在每次迭代时增加1，最终达到Integer.MAX_VALUE。 现在，当使用Hotspot 7在64位Mac OS X上启动代码片段时，应该得到类似于以下内容的输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">    at eu.plumbr.demo.ArraySize.main(ArraySize.java:8)</span><br><span class="line">java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">    at eu.plumbr.demo.ArraySize.main(ArraySize.java:8)</span><br><span class="line">java.lang.OutOfMemoryError: Requested array size exceeds VM limit</span><br><span class="line">    at eu.plumbr.demo.ArraySize.main(ArraySize.java:8)</span><br><span class="line">java.lang.OutOfMemoryError: Requested array size exceeds VM limit</span><br><span class="line">    at eu.plumbr.demo.ArraySize.main(ArraySize.java:8)</span><br></pre></td></tr></table></figure><p>注意，在出现<code>Requested array size exceeded VM limit</code>之前，出现了更熟悉的<code>java.lang.OutOfMemoryError: Java heap space</code>。 这是因为初始化2 ^ 31-1个元素的数组需要腾出8G的内存空间，大于JVM使用的默认值。</p><h4 id="解决方案-6"><a href="#解决方案-6" class="headerlink" title="解决方案"></a>解决方案</h4><p><code>java.lang.OutOfMemoryError:Requested array size exceeds VM limit</code>可能会在以下任一情况下出现：</p><ul><li>数组增长太大，最终大小在平台限制和<code>Integer.MAX_INT</code>之间</li><li>你有意分配大于<code>2 ^ 31-1</code>个元素的数组</li></ul><p>在第一种情况下，检查你的代码库，看看你是否真的需要这么大的数组。也许你可以减少数组的大小，或者将数组分成更小的数据块，然后分批处理数据。</p><p>在第二种情况下，记住Java数组是由int索引的。因此，当在平台中使用标准数据结构时，数组不能超过2 ^ 31-1个元素。事实上，在编译时就会出错：<code>error：integer number too large</code>。</p><h3 id="8、Out-of-memory-Kill-process-or-sacrifice-child"><a href="#8、Out-of-memory-Kill-process-or-sacrifice-child" class="headerlink" title="8、Out of memory:Kill process or sacrifice child"></a>8、<code>Out of memory:Kill process or sacrifice child</code></h3><p>为了理解这个错误，我们需要补充一点操作系统的基础知识。操作系统是建立在进程的概念之上，这些进程在内核中作业，其中有一个非常特殊的进程，名叫“内存杀手（Out of memory killer）”。当内核检测到系统内存不足时，OOM killer被激活，然后选择一个进程杀掉。哪一个进程这么倒霉呢？选择的算法和想法都很朴实：谁占用内存最多，谁就被干掉。如果你对OOM Killer感兴趣的话，建议你阅读参考资料2中的文章。</p><p>当可用虚拟虚拟内存(包括交换空间)消耗到让整个操作系统面临风险时，就会产生<code>Out of memory:Kill process or sacrifice child</code>错误。在这种情况下，OOM Killer会选择“流氓进程”并杀死它。</p><h4 id="原因分析-7"><a href="#原因分析-7" class="headerlink" title="原因分析"></a>原因分析</h4><p>默认情况下，Linux内核允许进程请求比系统中可用内存更多的内存，但大多数进程实际上并没有使用完他们所分配的内存。这就跟现实生活中的宽带运营商类似，他们向所有消费者出售一个100M的带宽，远远超过用户实际使用的带宽，一个10G的链路可以非常轻松的服务100个(10G/100M)用户，但实际上宽带运行商往往会把10G链路用于服务150人或者更多，以便让链路的利用率更高，毕竟空闲在那儿也没什么意义。</p><p>Linux内核采用的机制跟宽带运营商差不多，一般情况下都没有问题，但当大多数应用程序都消耗完自己的内存时，麻烦就来了，因为这些应用程序的内存需求加起来超出了物理内存（包括 swap）的容量，内核（OOM killer）必须杀掉一些进程才能腾出空间保障系统正常运行。就如同上面的例子中，如果150人都占用100M的带宽，那么总的带宽肯定超过了10G这条链路能承受的范围。</p><h4 id="示例-6"><a href="#示例-6" class="headerlink" title="示例"></a>示例</h4><p>当你在Linux上运行如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">    List&lt;int[]&gt; l = new java.util.ArrayList();</span><br><span class="line">    for (int i = 10000; i &lt; 100000; i++) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            l.add(new int[100000000]);</span><br><span class="line">        &#125; catch (Throwable t) &#123;</span><br><span class="line">            t.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Linux的系统日志中<code>/var/log/kern.log</code>会出现以下日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Jun  4 07:41:59 plumbr kernel: [70667120.897649] Out of memory: Kill process 29957 (java) score 366 or sacrifice child</span><br><span class="line">Jun  4 07:41:59 plumbr kernel: [70667120.897701] Killed process 29957 (java) total-vm:2532680kB, anon-rss:1416508kB, file-rss:0kB</span><br></pre></td></tr></table></figure><p>注意：你可能需要调整交换文件和堆大小，否则你将很快见到熟悉的<code>Java heap space</code>异常。在原作者的测试用例中，使用<code>-Xmx2g</code>指定的2g堆，并具有以下交换配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 注意：原作者使用，由于我手里并没有Linux环境，所以并未测试</span><br><span class="line">swapoff -a </span><br><span class="line">dd if=/dev/zero of=swapfile bs=1024 count=655360</span><br><span class="line">mkswap swapfile</span><br><span class="line">swapon swapfile</span><br></pre></td></tr></table></figure><h4 id="解决方案-7"><a href="#解决方案-7" class="headerlink" title="解决方案"></a>解决方案</h4><p>解决这个问题最有效也是最直接的方法就是升级内存，其他方法诸如：调整OOM Killer配置、水平扩展应用，将内存的负载分摊到若干小实例上….. 我们不建议的做法是增加交换空间，具体原因已经在前文说过。参考资料②中详细的介绍了怎样微调OOM Killer配置以及OOM Killer选择进程算法的实现，建议你参考阅读。</p><h4 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h4><p>① 想要了解更多PermGen与Metaspace的内容推荐你阅读：</p><ul><li><a href="https://link.jianshu.com?t=http%3A%2F%2Fwww.infoq.com%2Fcn%2Fnews%2F2013%2F03%2Fjava-8-permgen-metaspace" rel="external nofollow noopener noreferrer" target="_blank">Java 8会解决PermGen OutOfMemoryError问题吗?</a></li><li><a href="https://link.jianshu.com?t=http%3A%2F%2Fifeve.com%2Fjava-permgen-removed%2F" rel="external nofollow noopener noreferrer" target="_blank">Java PermGen 去哪里了?</a></li></ul><p>② 如果你对OOM Killer感兴趣的话，强烈建议你阅读这篇文章：</p><ul><li><a href="https://link.jianshu.com?t=http%3A%2F%2Fwww.vpsee.com%2F2013%2F10%2Fhow-to-configure-the-linux-oom-killer%2F" rel="external nofollow noopener noreferrer" target="_blank">理解和配置 Linux 下的 OOM Killer</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、java-lang-OutOfMemoryError-Java-heap-space&quot;&gt;&lt;a href=&quot;#1、java-lang-OutOfMemoryError-Java-heap-space&quot; class=&quot;headerlink&quot; title=&quot;1、ja
      
    
    </summary>
    
      <category term="Java" scheme="http://polyval.github.io/Wiki/categories/Java/"/>
    
    
      <category term="Java" scheme="http://polyval.github.io/Wiki/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>性能瓶颈</title>
    <link href="http://polyval.github.io/Wiki/wiki/Java/%E6%80%A7%E8%83%BD%E7%93%B6%E9%A2%88/"/>
    <id>http://polyval.github.io/Wiki/wiki/Java/性能瓶颈/</id>
    <published>2018-10-06T16:28:21.000Z</published>
    <updated>2018-10-11T04:51:52.455Z</updated>
    
    <content type="html"><![CDATA[<p>一个好的程序，应该是能够充分利用CPU。如果一个程序在单CPU的机器上无论在多大的压力下都无法令CPU的使用率接近100% ,说明这个程序设计地有问题。</p><h3 id="常见的性能瓶颈"><a href="#常见的性能瓶颈" class="headerlink" title="常见的性能瓶颈"></a>常见的性能瓶颈</h3><h4 id="不恰当的同步导致的资源占用"><a href="#不恰当的同步导致的资源占用" class="headerlink" title="不恰当的同步导致的资源占用"></a>不恰当的同步导致的资源占用</h4><ul><li><p>锁加得不恰当</p></li><li><p>锁粒度过大</p><h4 id="不恰当的线程模型"><a href="#不恰当的线程模型" class="headerlink" title="不恰当的线程模型"></a>不恰当的线程模型</h4></li></ul><h4 id="效率低下的SQL或者不恰当的数据库设计"><a href="#效率低下的SQL或者不恰当的数据库设计" class="headerlink" title="效率低下的SQL或者不恰当的数据库设计"></a>效率低下的SQL或者不恰当的数据库设计</h4><h4 id="不恰当的GC参数"><a href="#不恰当的GC参数" class="headerlink" title="不恰当的GC参数"></a>不恰当的GC参数</h4><h4 id="线程数量不足"><a href="#线程数量不足" class="headerlink" title="线程数量不足"></a>线程数量不足</h4><h4 id="内存泄露导致的频繁GC"><a href="#内存泄露导致的频繁GC" class="headerlink" title="内存泄露导致的频繁GC"></a>内存泄露导致的频繁GC</h4><h3 id="通过线程堆栈识别性能瓶颈"><a href="#通过线程堆栈识别性能瓶颈" class="headerlink" title="通过线程堆栈识别性能瓶颈"></a>通过线程堆栈识别性能瓶颈</h3><h4 id="典型的堆栈特征"><a href="#典型的堆栈特征" class="headerlink" title="典型的堆栈特征"></a>典型的堆栈特征</h4><ol><li>绝大多数线程的堆栈表现在<strong>同一个调用上下文</strong>上，且只剩下非常少的空闲线程</li><li>绝大多数线程处于<strong>等待状态</strong>，只有几个工作的线程，总体性能上不去。可能的原因是，<strong>系统存在关键路径</strong>，在该关键路径上没有足够的能力给下个阶段输送大量的任务，导致其 它地方空闲。如在消息分发系统，消息分发一般是一个线程，而消息处理是多个线程，这 时候消息分发是瓶颈的话，那么从线程堆栈就会观察到上面提到的现象:即该关键路径 没有足够的能力给下个阶段输送大量的任务，导致其它地方空闲</li><li><strong>线程总的数量很少</strong>。这个一般与线程池的设计有关。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一个好的程序，应该是能够充分利用CPU。如果一个程序在单CPU的机器上无论在多大的压力下都无法令CPU的使用率接近100% ,说明这个程序设计地有问题。&lt;/p&gt;
&lt;h3 id=&quot;常见的性能瓶颈&quot;&gt;&lt;a href=&quot;#常见的性能瓶颈&quot; class=&quot;headerlink&quot; t
      
    
    </summary>
    
      <category term="Java" scheme="http://polyval.github.io/Wiki/categories/Java/"/>
    
    
      <category term="Java" scheme="http://polyval.github.io/Wiki/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>React Virtual DOM</title>
    <link href="http://polyval.github.io/Wiki/wiki/%E5%89%8D%E7%AB%AF/React%20Vitual%20DOM/"/>
    <id>http://polyval.github.io/Wiki/wiki/前端/React Vitual DOM/</id>
    <published>2018-10-06T16:28:21.000Z</published>
    <updated>2018-10-11T04:49:39.474Z</updated>
    
    <content type="html"><![CDATA[<h3 id="为什么说操作DOM慢"><a href="#为什么说操作DOM慢" class="headerlink" title="为什么说操作DOM慢"></a>为什么说操作DOM慢</h3><p>DOM对象本身是一个js对象，其实操作这个对象并不慢，慢的是操作这个对象后，会触发一些浏览器行为，比如布局(layout)和绘制(paint)。</p><h4 id="浏览器渲染主要流程"><a href="#浏览器渲染主要流程" class="headerlink" title="浏览器渲染主要流程"></a>浏览器渲染主要流程</h4><p><a href="https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/" rel="external nofollow noopener noreferrer" target="_blank">浏览器如何工作的</a></p><p>浏览器对HTMl的渲染分为5个步骤：</p><ol><li>处理<strong>HTML</strong>标记并构建出DOM树</li><li>处理<strong>CSS</strong>标记并构建CSSOM树</li><li>将两者<strong>关联</strong>生成Render Tree</li><li><strong>Layout</strong>根据Render Tree来布局，计算每个节点的几何信息</li><li>根据计算好的信息<strong>绘制</strong>整个页面</li></ol><p>其中，layout是最耗时的步骤。因此需要最小化layout的次数</p><h4 id="什么情况下浏览器会进行layout"><a href="#什么情况下浏览器会进行layout" class="headerlink" title="什么情况下浏览器会进行layout"></a>什么情况下浏览器会进行layout</h4><p>layout用来计算文档中元素的位置和大小，在HTML第一次被加载的时候，会有一次layout，称为reflow/如下操作也会触发reflow</p><ul><li>插入、删除、移动、更新DOM</li><li>改变页面内容，如输入框的文本</li><li>改变CSS样式</li><li>改变窗口大小</li></ul><h4 id="Vitual-DOM更快么"><a href="#Vitual-DOM更快么" class="headerlink" title="Vitual DOM更快么"></a>Vitual DOM更快么</h4><p>Virtual DOM并不比直接操作DOM快，只不过使用Vitual DOM可以减少不必要的DOM更新，从而减少比较耗时的layout和paint工作。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;为什么说操作DOM慢&quot;&gt;&lt;a href=&quot;#为什么说操作DOM慢&quot; class=&quot;headerlink&quot; title=&quot;为什么说操作DOM慢&quot;&gt;&lt;/a&gt;为什么说操作DOM慢&lt;/h3&gt;&lt;p&gt;DOM对象本身是一个js对象，其实操作这个对象并不慢，慢的是操作这个对象后，
      
    
    </summary>
    
      <category term="前端" scheme="http://polyval.github.io/Wiki/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="React" scheme="http://polyval.github.io/Wiki/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>操作系统是如何实现虚拟内存的</title>
    <link href="http://polyval.github.io/Wiki/wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84/"/>
    <id>http://polyval.github.io/Wiki/wiki/操作系统/操作系统是如何实现虚拟内存的/</id>
    <published>2018-10-06T16:28:21.000Z</published>
    <updated>2018-10-11T04:48:14.995Z</updated>
    
    <content type="html"><![CDATA[<p>要明白操作系统是如何实现虚拟内存的，首先应该明白操作系统为什么要需要虚拟内存</p><h2 id="为什么需要虚拟内存"><a href="#为什么需要虚拟内存" class="headerlink" title="为什么需要虚拟内存"></a>为什么需要虚拟内存</h2><p>早期的程序中访问的内存地址都是实际的物理内存地址。</p><p>程序需要加载在内存上运行，即形成进程。起初，只有一个进程信息可以被加载到内存，需要运行另一个进程时，需要将当前进程的信息先存储到磁盘上，然后从磁盘上读取另一个进程的信息。但是磁盘I/O是很慢的，导致任务切换的效率很低 。因此，人们希望将多个进程可以共同存放在内存上，这就出现了一个问题：如何避免一个进程读取、篡改另一个进程的内存信息，即对进程间实现<strong>隔离</strong>和<strong>保护</strong>。</p><p>同时，程序在编写时，其访问数据和指令跳转时的目标地址很多是固定的。但是程序在加载在内存时，不可能说每次我们都能够分配固定地址的内存给它。尤其是在我们想运行同一程序的多个实例的时候，由于同一程序使用的物理地址是一样的，一起运行就会有冲突。</p><p>另外，程序使用的内存会被物理内存所限制，即程序使用的内存不能超过物理内存。</p><p>内存虚拟化就是为了解决这些问题出现的，它将程序给的地址看作是虚拟地址(Virtual Address)，然后通过将虚拟地址转换为实际的物理地址，通过操作系统对这个转化过程的控制，来实现<strong>隔离、保护、和易用</strong>。</p><h2 id="如何实现虚拟内存"><a href="#如何实现虚拟内存" class="headerlink" title="如何实现虚拟内存"></a>如何实现虚拟内存</h2><p>我们可以把我们为什么需要虚拟内存抽象成虚拟内存要实现的几个目标。</p><h3 id="虚拟内存的几个目标"><a href="#虚拟内存的几个目标" class="headerlink" title="虚拟内存的几个目标"></a>虚拟内存的几个目标</h3><ul><li><p><strong>不可见性</strong></p><blockquote><p>即对于程序来说，并不知道内存被虚拟化了，程序认为自己拥有独自的物理内存</p></blockquote></li><li><p><strong>高效率</strong></p><blockquote><p>虚拟内存的效率要高,不能让程序运行变得太慢(时间效率),也不能因为实现虚拟内存占用太大空间(空间效率)。为了保证时间效率，需要用到硬件的支持。</p></blockquote></li><li><p><strong>保护</strong></p><blockquote><p>操作系统需要保证进程间相互隔离，同时也要将操作系统与进程隔离开来。</p></blockquote></li></ul><p>实现虚拟内存的关键技术是：地址转化，实现地址转化的硬件称为内存管理单元<strong>MMU</strong>(Memory Management Unit)。我们先来看看地址转化最初的原型：<strong>base and bounds</strong>，也叫<strong>动态重定位</strong>(dynamic relocation)。</p><h3 id="动态重定位"><a href="#动态重定位" class="headerlink" title="动态重定位"></a>动态重定位</h3><p>在动态重定位方法中，每个CPU需要两个寄存器来帮助它实现地址转化：base register 和 bounds register。</p><p>程序在编写和编译时，其使用的内存地址从0开始。当程序运行时，如OS打算在32KB处开始载入程序，则OS将base寄存器的值设为32KB。程序的地址转化成：<br>$$<br>实际物理地址 = 虚拟地址 + base<br>$$<br>因此，base寄存器实现了地址转化的作用，而bounds寄存器的作用则是进行保护，限制地址引用的范围。</p><p>当进行进程间切换时，需要保存base-bounds寄存器的值，以便恢复进程。这个值保存在进程控制块PCB(process control block)里。</p><h4 id="动态重定位的缺点"><a href="#动态重定位的缺点" class="headerlink" title="动态重定位的缺点"></a>动态重定位的缺点</h4><p>动态重定位的缺点在于它会造成<strong>内部碎片(internal fragmentation)</strong>，造成内存的浪费。如图所示，由于进程的堆和栈不是很大，其中的内存就被浪费掉了</p><p><img src="/Wiki/wiki/操作系统/操作系统是如何实现虚拟内存的/内部碎片.png" alt="内部碎片">。</p><p><strong>为了解决内部碎片的问题，出现了分段技术。</strong></p><h3 id="分段-Segmentation"><a href="#分段-Segmentation" class="headerlink" title="分段(Segmentation)"></a>分段(Segmentation)</h3><p>分段技术的出现是为了解决程序因占用连续的内存空间而产生内部碎片的问题，利用分段解决内部碎片问题的思想很简单：将进程的内存空间按照逻辑进行分段，每段可存放在物理内存的不同位置，在动态重定位一对base-bounds寄存器的基础上，<strong>给进程的每段都分配一对base-bounds寄存器</strong>。常见分段方式分为三段：代码段、栈和堆。比如说我们要对某个代码段的虚拟地址进行寻址，只需要根据代码段的base-bounds寄存器，按照动态重定位的方式寻址即可。那么，给定一个虚拟地址，如何判断它是属于哪个段的呢？</p><h4 id="如何确定虚拟地址属于哪个段"><a href="#如何确定虚拟地址属于哪个段" class="headerlink" title="如何确定虚拟地址属于哪个段"></a>如何确定虚拟地址属于哪个段</h4><p>有两种方法进行确定。</p><h5 id="将地址前面几位当作段标志"><a href="#将地址前面几位当作段标志" class="headerlink" title="将地址前面几位当作段标志"></a>将地址前面几位当作段标志</h5><p>比如一个14位的虚拟内存，我们可以将其前两位当做段的标志位，如00表示代码段，01表示堆，11表示栈。</p><p><img src="/Wiki/wiki/操作系统/操作系统是如何实现虚拟内存的/段.png" alt="段"></p><h5 id="根据虚拟地址如何产生的来判断"><a href="#根据虚拟地址如何产生的来判断" class="headerlink" title="根据虚拟地址如何产生的来判断"></a>根据虚拟地址如何产生的来判断</h5><p>如果虚拟地址由程序计数器(program count)产生的，则为代码段，如果为栈指针，则为栈段，否则为堆段。</p><h4 id="MMU记录的其它信息"><a href="#MMU记录的其它信息" class="headerlink" title="MMU记录的其它信息"></a>MMU记录的其它信息</h4><p>除了每段的base-bounds寄存器外，MMU还记录了段的其它一些信息。</p><p><img src="/Wiki/wiki/操作系统/操作系统是如何实现虚拟内存的/段寄存器.png" alt="段寄存器"></p><p>因为栈是反方向扩张的，因此需要记录内存扩张的方向。Protection用来表示段的属性，可以用来共享一些段。</p><h4 id="分段的缺点"><a href="#分段的缺点" class="headerlink" title="分段的缺点"></a>分段的缺点</h4><p>每个程序都不一样，其各段所占用的内存空间大小也不一样，造成内存的占用情况如下图所示</p><p><img src="/Wiki/wiki/操作系统/操作系统是如何实现虚拟内存的/分段的缺点.png" alt="分段的缺点"></p><p>内存上出现了各种大小的小洞，如果我们需要分配一个新段，比这个新段大小小的内存空间对于我们来说都是没有用的，这就造成了内存的浪费，这种浪费称为<strong>外部碎片(external fragmentation)</strong>。为了解决这个问题，出现了各种方法，如<strong>内存整理</strong>(compact)，各种<strong>内存管理算法</strong>(best fit、first fit)。但是并没有完美的方法解决这个问题。</p><h3 id="分页-Paging"><a href="#分页-Paging" class="headerlink" title="分页(Paging)"></a>分页(Paging)</h3><p>分段中引起外部碎片的原因是每段的大小都不一样。分页对内存的处理方式是:将虚拟内存和物理内存分为若干个固定长度的单元，这个单元称为页。</p><h4 id="如何寻址"><a href="#如何寻址" class="headerlink" title="如何寻址"></a>如何寻址</h4><p>每个进程都对应一个<strong>页表</strong>(page table)，页表存储着虚拟内存页对应的实际物理内存页。虚拟地址需要分为两部分：虚拟页号VPN(virtual page number)和偏移量offset。通过页表可以知道VPN对应的PFN，通过offset进行准确寻址。</p><p><img src="/Wiki/wiki/操作系统/操作系统是如何实现虚拟内存的/分页.png" alt="分页"></p><h4 id="页表存放在哪"><a href="#页表存放在哪" class="headerlink" title="页表存放在哪"></a>页表存放在哪</h4><p>页表占用空间很大。举个例子，假设一个32位的地址空间，每页大小为4KB，则虚拟内存分为20位的VPN和12位的偏移量(10位1KB，4KB则为12位)。20位的VPN表示存在$2^{20}$条转化映射，假设每条映射占用4字节，则一个页表需要占用4M的大小。</p><p>由于页表太大，因此将内部存储在内存中。在MMU中的<strong>页表基(page-table base)寄存器</strong>中存放页表在内存中的起始位置。</p><h4 id="分页的缺点"><a href="#分页的缺点" class="headerlink" title="分页的缺点"></a>分页的缺点</h4><p>因为页表存放在内存上，在对虚拟地址进行转化时，首先需要从内存中的页表读到其对应物理页，相当于多了一次内存的读操作，<strong>因此分页会降低速度，同时页表的存储占用过多内存。</strong></p><h4 id="给分页加加速"><a href="#给分页加加速" class="headerlink" title="给分页加加速"></a>给分页加加速</h4><p>要想加加速，就需要硬件来帮个忙。<strong>TLB</strong> (Translation-Lookaside Buffer)，中文译为<strong>快表</strong>。TLB是集成在MMU上的缓存，用来存储部分页表记录。</p><p>查询页表时，首先去TLB查，查到了称为TLB命中(hit)，如果没查到，称为TLB失败(miss)，此时去内存中的页表查。缓存大小有限，当有新记录放入到TLB，需要进行缓存置换，缓存置换有许多方法，这里不再展开。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;要明白操作系统是如何实现虚拟内存的，首先应该明白操作系统为什么要需要虚拟内存&lt;/p&gt;
&lt;h2 id=&quot;为什么需要虚拟内存&quot;&gt;&lt;a href=&quot;#为什么需要虚拟内存&quot; class=&quot;headerlink&quot; title=&quot;为什么需要虚拟内存&quot;&gt;&lt;/a&gt;为什么需要虚拟内存&lt;/h2
      
    
    </summary>
    
      <category term="操作系统" scheme="http://polyval.github.io/Wiki/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="http://polyval.github.io/Wiki/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>线程状态</title>
    <link href="http://polyval.github.io/Wiki/wiki/Java/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81/"/>
    <id>http://polyval.github.io/Wiki/wiki/Java/线程状态/</id>
    <published>2018-10-06T16:28:21.000Z</published>
    <updated>2018-10-11T04:54:00.830Z</updated>
    
    <content type="html"><![CDATA[<h3 id="线程的状态转换关系"><a href="#线程的状态转换关系" class="headerlink" title="线程的状态转换关系"></a>线程的状态转换关系</h3><p><img src="/Wiki/wiki/Java/线程状态/线程状态.png" alt="线程状态"></p><p>1）<strong>BLOCKED</strong>：线程等待监视器锁，就是线程在等待获取锁进入同步块或者同步方法中。两个死锁的线程即是Blocked。</p><p>2）<strong>WAITING</strong>：</p><p>三种方法可以使线程进入WAITING:</p><ul><li><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#wait--" rel="external nofollow noopener noreferrer" target="_blank">Object.wait</a> with no timeout</li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html#join--" rel="external nofollow noopener noreferrer" target="_blank">Thread.join</a> with no timeout</li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/LockSupport.html#park--" rel="external nofollow noopener noreferrer" target="_blank">LockSupport.park</a></li></ul><p>比BLOCKED状态进步一些，指我已经获得锁了，但由于有些条件不满足，我自己等会，调用object.wait()方法。等条件满足了，别的线程调用notify再叫我。另外也可以调用Thread.join()方法，顾名思义就是调用别的线程的join方法，让别人join进来先执行，那我就只能等会了。但是由于wait()和notify()以及notifyAll()用于协调对共享资源的存取，所以必须在synchronized块中使用，即调用wait的时候需要获取锁，调用后锁释放。所以即便wait状态的线程被notfiy唤醒了，也需要再次获得锁，所以唤醒后进入Blocked状态。</p><p>3）<strong>TIMED_WAITING</strong>：</p><p>如下方法使线程进入该状态</p><ul><li><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html#sleep-long-" rel="external nofollow noopener noreferrer" target="_blank">Thread.sleep</a></li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#wait-long-" rel="external nofollow noopener noreferrer" target="_blank">Object.wait</a> with timeout</li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html#join-long-" rel="external nofollow noopener noreferrer" target="_blank">Thread.join</a> with timeout</li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/LockSupport.html#parkNanos-java.lang.Object-long-" rel="external nofollow noopener noreferrer" target="_blank">LockSupport.parkNanos</a></li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/LockSupport.html#parkUntil-java.lang.Object-long-" rel="external nofollow noopener noreferrer" target="_blank">LockSupport.parkUntil</a></li></ul><p>类比WAITING，差异是不需要notify()或者notifyAlL()方法唤醒，时间到了我自己醒了。另外sleep比较好理解，就是让当前线程睡一会，与wait的区别是它不释放锁。</p><p>4）<strong>RUNNABLE</strong>不用多说，在JAVA虚拟机中已经在运行，但是有可能在等待操作系统资源，比如CPU时间片。</p><ul><li><p>处于Runnable的线程一定消耗cpu么</p><blockquote><p>不一定，比如线程处于io等待，实际上是线程是挂起，不消耗cpu的。</p></blockquote><h3 id="Java线程堆栈解读"><a href="#Java线程堆栈解读" class="headerlink" title="Java线程堆栈解读"></a>Java线程堆栈解读</h3></li></ul><h4 id="tid和nid"><a href="#tid和nid" class="headerlink" title="tid和nid"></a>tid和nid</h4><p>在采集Java线程堆栈时，有个nid和tid。tid表示Java层面的线程id，是Java给每个线程所分配的一个id，nid(Native thread ID)表示的本地线程id，与实际的操作系统线程id相一致。</p><h4 id="堆栈中与锁相关的三种状态"><a href="#堆栈中与锁相关的三种状态" class="headerlink" title="堆栈中与锁相关的三种状态"></a>堆栈中与锁相关的三种状态</h4><ul><li>当一个线程占有一个锁的时候，线程堆栈中会打印—locked <0x22bffb60> </0x22bffb60></li><li>当一个线程正在等待其它线程释放该锁，线程堆栈中会打印—<strong>waiting to lock</strong> <0x22bffb60> </0x22bffb60></li><li>当一个线程占有一个锁，但又执行到该锁的wait()上，线程堆栈中首先打印locked,然后又 会打印—<strong>waiting on</strong> <0x22c03c60> </0x22c03c60></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;线程的状态转换关系&quot;&gt;&lt;a href=&quot;#线程的状态转换关系&quot; class=&quot;headerlink&quot; title=&quot;线程的状态转换关系&quot;&gt;&lt;/a&gt;线程的状态转换关系&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/Wiki/wiki/Java/线程状态/线程状态.png&quot; a
      
    
    </summary>
    
      <category term="Java" scheme="http://polyval.github.io/Wiki/categories/Java/"/>
    
    
      <category term="Java" scheme="http://polyval.github.io/Wiki/tags/Java/"/>
    
  </entry>
  
</feed>
