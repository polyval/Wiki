<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    
    <title>polyval&#39;s Wiki</title>
    
    
        <meta name="keywords" content="polyval&#39;s Wiki">
    
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="description" content="Java搜索技巧末尾加上PDF，可以搜出一些高质量的文章，包括一些技术分享、大学的课件。 Wikipedia看参考文献，会有很多不错的资料。 关键字：Overview，Demystify 学习过程：从宏观上了解 基础StringString.intern()如果常量池中存在当前字符串, 就会直接返回当前字符串. 如果常量池中没有此字符串, 会将此字符串放入常量池中后, 再返回。常量池是堆中的一块特">
<meta property="og:type" content="article">
<meta property="og:title" content="polyval&#39;s Wiki">
<meta property="og:url" content="http://polyval.github.io/Wiki/wiki/Java/笔记/index.html">
<meta property="og:site_name" content="polyval&#39;s Wiki">
<meta property="og:description" content="Java搜索技巧末尾加上PDF，可以搜出一些高质量的文章，包括一些技术分享、大学的课件。 Wikipedia看参考文献，会有很多不错的资料。 关键字：Overview，Demystify 学习过程：从宏观上了解 基础StringString.intern()如果常量池中存在当前字符串, 就会直接返回当前字符串. 如果常量池中没有此字符串, 会将此字符串放入常量池中后, 再返回。常量池是堆中的一块特">
<meta property="og:locale" content="en">
<meta property="og:image" content="http://polyval.github.io/Wiki/wiki/Java/笔记/java-monitor-associate-with-object.jpg">
<meta property="og:image" content="http://polyval.github.io/Wiki/wiki/Java/笔记/fig20-1.gif">
<meta property="og:image" content="http://polyval.github.io/Wiki/wiki/Java/笔记/image-20190410212710712.png">
<meta property="og:image" content="http://polyval.github.io/Wiki/wiki/Java/笔记/v2-9db4211af1be81785f6cc51a58ae6054_r.jpg">
<meta property="og:image" content="http://polyval.github.io/Wiki/wiki/Java/笔记/clip_image002.png">
<meta property="og:image" content="http://polyval.github.io/Wiki/wiki/Java/笔记/clip_image003.png">
<meta property="og:image" content="http://polyval.github.io/Wiki/wiki/Java/笔记/clip_image004.png">
<meta property="og:image" content="http://polyval.github.io/Wiki/wiki/Java/笔记/clip_image005.png">
<meta property="og:image" content="http://polyval.github.io/Wiki/wiki/Java/笔记/clip_image006.png">
<meta property="og:image" content="http://polyval.github.io/Wiki/wiki/Java/笔记/clip_image008.png">
<meta property="og:image" content="http://polyval.github.io/Wiki/wiki/Java/笔记/image-20190401131756815.png">
<meta property="og:updated_time" content="2019-09-12T22:25:02.015Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="polyval&#39;s Wiki">
<meta name="twitter:description" content="Java搜索技巧末尾加上PDF，可以搜出一些高质量的文章，包括一些技术分享、大学的课件。 Wikipedia看参考文献，会有很多不错的资料。 关键字：Overview，Demystify 学习过程：从宏观上了解 基础StringString.intern()如果常量池中存在当前字符串, 就会直接返回当前字符串. 如果常量池中没有此字符串, 会将此字符串放入常量池中后, 再返回。常量池是堆中的一块特">
<meta name="twitter:image" content="http://polyval.github.io/Wiki/wiki/Java/笔记/java-monitor-associate-with-object.jpg">
    

    

    
        <link rel="icon" href="/Wiki/favicon.ico">
    

    <link rel="stylesheet" href="/Wiki/libs/font-awesome/css/font-awesome.min.css">
    <link rel="stylesheet" href="/Wiki/libs/open-sans/styles.css">
    <link rel="stylesheet" href="/Wiki/libs/source-code-pro/styles.css">

    <link rel="stylesheet" href="/Wiki/css/style.css">
    <script src="/Wiki/libs/jquery/2.1.3/jquery.min.js"></script>
    <script src="/Wiki/libs/jquery/plugins/cookie/1.4.1/jquery.cookie.js"></script>
    
    
        <link rel="stylesheet" href="/Wiki/libs/lightgallery/css/lightgallery.min.css">
    
    
        <link rel="stylesheet" href="/Wiki/libs/justified-gallery/justifiedGallery.min.css">
    
    
    
    


    
        <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    
</head>
</html>
<body>
    <div id="container">
        <header id="header">
    <div id="header-main" class="header-inner">
        <div class="outer">
            <a href="/Wiki/" id="logo">
                <i class="logo"></i>
                <span class="site-title">polyval&#39;s Wiki</span>
            </a>
            <nav id="main-nav">
                
                    <a class="main-nav-link" href="/Wiki/">首页</a>
                
                    <a class="main-nav-link" href="/Wiki/archives">归档</a>
                
                    <a class="main-nav-link" href="/Wiki/categories">分类</a>
                
                    <a class="main-nav-link" href="/Wiki/tags">标签</a>
                
                    <a class="main-nav-link" href="/Wiki/about">关于</a>
                
            </nav>
            
            <div id="search-form-wrap">

    <form class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="Search">
        <button type="submit" class="search-form-submit"></button>
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="Type something...">
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: 'Posts',
            PAGES: 'Pages',
            CATEGORIES: 'Categories',
            TAGS: 'Tags',
            UNTITLED: '(Untitled)',
        },
        ROOT_URL: '/Wiki/',
        CONTENT_URL: '/Wiki/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/Wiki/js/insight.js"></script>

</div>
        </div>
    </div>
    <div id="main-nav-mobile" class="header-sub header-inner">
        <table class="menu outer">
            <tr>
                
                    <td><a class="main-nav-link" href="/Wiki/">首页</a></td>
                
                    <td><a class="main-nav-link" href="/Wiki/archives">归档</a></td>
                
                    <td><a class="main-nav-link" href="/Wiki/categories">分类</a></td>
                
                    <td><a class="main-nav-link" href="/Wiki/tags">标签</a></td>
                
                    <td><a class="main-nav-link" href="/Wiki/about">关于</a></td>
                
                <td>
                    
    <div class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="Search">
    </div>

                </td>
            </tr>
        </table>
    </div>
</header>

        <div class="outer">
            
            
                <aside id="sidebar">
   
        
    <div class="widget-wrap" id="categories">
        <h3 class="widget-title">
            <span>categories</span>
            &nbsp;
            <a id="allExpand" href="#">
                <i class="fa fa-angle-double-down fa-2x"></i>
            </a>
        </h3>
        
        
        
         <ul class="unstyled" id="tree"> 
                    <li class="directory open">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder-open"></i>
                            &nbsp;
                            Java
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/Wiki/wiki/Java/CPU占用过高定位/">CPU占用过高定位</a></li>  <li class="file"><a href="/Wiki/wiki/Java/CAS/">CAS</a></li>  <li class="file"><a href="/Wiki/wiki/Java/Condition/">Condition</a></li>  <li class="file"><a href="/Wiki/wiki/Java/CountDownLatch/">CountDownLatch&CyclicBarrier</a></li>  <li class="file"><a href="/Wiki/wiki/Java/HashMap/">HashMap</a></li>  <li class="file"><a href="/Wiki/wiki/Java/Java内存优化/">Java内存优化</a></li>  <li class="file"><a href="/Wiki/wiki/Java/Java分析工具/">Java分析工具</a></li>  <li class="file"><a href="/Wiki/wiki/Java/ReentrantLock/">ReentrantLock</a></li>  <li class="file"><a href="/Wiki/wiki/Java/ReentrantReadWriteLock/">ReentrantReadWriteLock</a></li>  <li class="file"><a href="/Wiki/wiki/Java/性能瓶颈/">性能瓶颈</a></li>  <li class="file"><a href="/Wiki/wiki/Java/线程状态/">线程状态</a></li>  <li class="file"><a href="/Wiki/wiki/Java/AQS/">AQS</a></li>  <li class="file"><a href="/Wiki/wiki/Java/什么是Java内存模型/">什么是Java内存模型</a></li>  <li class="file active"><a href="/Wiki/wiki/Java/笔记/"></a></li>  <li class="file"><a href="/Wiki/wiki/Java/Java内存溢出的情况/">Java内存溢出的情况</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            云计算
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/Wiki/wiki/云计算/云计算/">云计算</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            分布式
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/Wiki/wiki/分布式/CAP定理/">CAP定理</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            前端
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/Wiki/wiki/前端/React Vitual DOM/">React Virtual DOM</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            工具
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/Wiki/wiki/工具/Git/">Git</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            微服务
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/Wiki/wiki/微服务/什么是微服务/">什么是微服务</a></li>  <li class="file"><a href="/Wiki/wiki/微服务/Spring Cloud/">Spring Cloud</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            操作系统
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/Wiki/wiki/操作系统/Linux命令/">Linux命令</a></li>  <li class="file"><a href="/Wiki/wiki/操作系统/操作系统是如何实现虚拟内存的/">操作系统是如何实现虚拟内存的</a></li>  </ul> 
                    </li> 
                     </ul> 
    </div>
    <script>
        $(document).ready(function() {
            var iconFolderOpenClass  = 'fa-folder-open';
            var iconFolderCloseClass = 'fa-folder';
            var iconAllExpandClass = 'fa-angle-double-down';
            var iconAllPackClass = 'fa-angle-double-up';
            // Handle directory-tree expansion:
            // 左键单独展开目录
            $(document).on('click', '#categories a[data-role="directory"]', function (event) {
                event.preventDefault();

                var icon = $(this).children('.fa');
                var expanded = icon.hasClass(iconFolderOpenClass);
                var subtree = $(this).siblings('ul');
                icon.removeClass(iconFolderOpenClass).removeClass(iconFolderCloseClass);
                if (expanded) {
                    if (typeof subtree != 'undefined') {
                        subtree.slideUp({ duration: 100 });
                    }
                    icon.addClass(iconFolderCloseClass);
                } else {
                    if (typeof subtree != 'undefined') {
                        subtree.slideDown({ duration: 100 });
                    }
                    icon.addClass(iconFolderOpenClass);
                }
            });
            // 右键展开下属所有目录
            $('#categories a[data-role="directory"]').bind("contextmenu", function(event){
                event.preventDefault();
                
                var icon = $(this).children('.fa');
                var expanded = icon.hasClass(iconFolderOpenClass);
                var listNode = $(this).siblings('ul');
                var subtrees = $.merge(listNode.find('li ul'), listNode);
                var icons = $.merge(listNode.find('.fa'), icon);
                icons.removeClass(iconFolderOpenClass).removeClass(iconFolderCloseClass);
                if(expanded) {
                    subtrees.slideUp({ duration: 100 });
                    icons.addClass(iconFolderCloseClass);
                } else {
                    subtrees.slideDown({ duration: 100 });
                    icons.addClass(iconFolderOpenClass);
                }
            })
            // 展开关闭所有目录按钮
            $(document).on('click', '#allExpand', function (event) {
                event.preventDefault();
                
                var icon = $(this).children('.fa');
                var expanded = icon.hasClass(iconAllExpandClass);
                icon.removeClass(iconAllExpandClass).removeClass(iconAllPackClass);
                if(expanded) {
                    $('#sidebar .fa.fa-folder').removeClass('fa-folder').addClass('fa-folder-open')
                    $('#categories li ul').slideDown({ duration: 100 });
                    icon.addClass(iconAllPackClass);
                } else {
                    $('#sidebar .fa.fa-folder-open').removeClass('fa-folder-open').addClass('fa-folder')
                    $('#categories li ul').slideUp({ duration: 100 });
                    icon.addClass(iconAllExpandClass);
                }
            });  
        });
    </script>

    
    <div id="toTop" class="fa fa-angle-up"></div>
</aside>
            
            <section id="main"><article id="post-Java/笔记" class="article article-type-post" itemscope="" itemprop="blogPost">
    <div class="article-inner">
        
        
        
        <div class="article-entry" itemprop="articleBody">
        
        
            
        
        
            <h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><h2 id="搜索技巧"><a href="#搜索技巧" class="headerlink" title="搜索技巧"></a>搜索技巧</h2><p>末尾加上PDF，可以搜出一些高质量的文章，包括一些技术分享、大学的课件。</p>
<p>Wikipedia看参考文献，会有很多不错的资料。</p>
<p>关键字：Overview，Demystify</p>
<p>学习过程：从宏观上了解</p>
<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><h4 id="String-intern"><a href="#String-intern" class="headerlink" title="String.intern()"></a>String.intern()</h4><p>如果常量池中存在当前字符串, 就会直接返回当前字符串. 如果常量池中没有此字符串, 会将此字符串放入常量池中后, 再返回。常量池是堆中的一块特殊区域。</p>
<h3 id="hashCode-和equals"><a href="#hashCode-和equals" class="headerlink" title="hashCode()和equals()"></a>hashCode()和equals()</h3><h4 id="hashcode规约"><a href="#hashcode规约" class="headerlink" title="hashcode规约"></a>hashcode规约</h4><ul>
<li><p>对同一对象，hashcode方法返回值每次应相同</p>
<blockquote>
<p>如果不同，则会导致根据hashcode变化无法在桶中找到该元素。Python字典中要求key需要是immutable的也是这个原因</p>
</blockquote>
</li>
<li><p>如果重写了equals()方法，检查条件“两个对象使用equals()方法判断为相等，则hashCode()方法也应该相等”是否成立，如果不成立，则重写hashCode ()方法。</p>
</li>
<li><p>不要求不同对象返回不同hashcode，但是如果每个对象都可以返回不同的hashcode，可以提高hash table的性能。</p>
</li>
</ul>
<h4 id="重写equals时为什么要重写hashcode"><a href="#重写equals时为什么要重写hashcode" class="headerlink" title="重写equals时为什么要重写hashcode"></a>重写equals时为什么要重写hashcode</h4><p>不重写hashcode方法，涉及到HashMap、HashSet等依赖对象hashcode值的集合会出问题。</p>
<p>HashMap通过hashcode将对象放到对应的桶结构中，在取数据时，根据hashcode定位到桶，然后根据equal在桶中寻找到对象。</p>
<p>如果不重写hashcode，就可能出现两个相同的对象(业务上)，由于hashcode不同，而会在HashMap中存两份。</p>
<h3 id="synchronized关键字原理"><a href="#synchronized关键字原理" class="headerlink" title="synchronized关键字原理"></a>synchronized关键字原理</h3><p>synchronized通过monitor来实现线程同步，而monitor是通过mutex lock和condition variable来实现互斥，每个Java对象(包括类对象)都有个mutex lock。在synchronized包裹的代码前后会有monitorenter和moniterexit指令。Monitor中的互斥锁是OS层面来支持，在获取(monitor entry)和释放锁(monitor exit)存在大量的开销。因此HotSpot VM在这方面做了些<a href="https://pdfs.semanticscholar.org/edf9/54412a9b1ce955bea148199f325759779540.pdf?_ga=2.63410607.1434231496.1554627760-821097055.1554627760" rel="external nofollow noopener noreferrer" target="_blank">优化</a>，引入了轻量级锁和偏向锁等。</p>
<h4 id="monitor"><a href="#monitor" class="headerlink" title="monitor"></a>monitor</h4><p><a href="https://www.artima.com/insidejvm/ed2/threadsynchP.html" rel="external nofollow noopener noreferrer" target="_blank">监视器</a>是一个可以实现线程互斥和协作的结构。</p>
<p>监视器可以看作一个房子，这个房子有个只能被一个线程占有的特殊的房间，房间里保护的就是临界资源。</p>
<p><img src="/Wiki/wiki/Java/笔记/java-monitor-associate-with-object.jpg" alt="img"></p>
<p>如果一个线程需要进入特殊房间，首选需要在大门(Entry Set)中等待，由调度策略决定下一个进入房间的是哪个线程。如果线程由于某种原因被挂起，则进入Wait Set，在合适的时间会被安排到特殊房间里。</p>
<p>进入房子 - entering the monitor</p>
<p>进入特殊房间 - acquiring the monitor</p>
<p>占据特殊房间 - owning the monitor</p>
<p>离开特殊房间 - releasing the monitor</p>
<p>离开房子 - exiting the monitor</p>
<p><strong>Synchornized</strong>关键字就是将其包裹的代码块放入特殊房间里，线程需要先enter the monitor后进入entry set，之后acquire the monitor才能运行代码块。</p>
<p><strong>wait和notify</strong>也是利用monitor，原理是：当一个线程own the monitor时，可以调用wait方法来将自己挂起，release the monitor并进入到Wait Set中，直到其他在拥有monitor的线程调用notify方法。当线程调用notify时，并不是立马就release the monitor，只有当线程release the monitor后，等待线程才会去acquire the monitor，但是monitor也可能被其他线程获取到，因此即使wait线程获取到monitor，也需要检查下数据是否满足其想要的条件。</p>
<p><img src="/Wiki/wiki/Java/笔记/fig20-1.gif" alt="Figure 20-1. A Java monitor."></p>
<h3 id="synchronized锁的优化"><a href="#synchronized锁的优化" class="headerlink" title="synchronized锁的优化"></a>synchronized锁的优化</h3><p>Monitor中的互斥锁是OS层面来支持，在获取(monitor entry)和释放锁(monitor exit)时存在大量的开销。因此HotSpot VM在这方面做了些<a href="https://pdfs.semanticscholar.org/edf9/54412a9b1ce955bea148199f325759779540.pdf?_ga=2.63410607.1434231496.1554627760-821097055.1554627760" rel="external nofollow noopener noreferrer" target="_blank">优化</a>。</p>
<h4 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h4><p><a href="https://tech.meituan.com/2018/11/15/java-lock.html" rel="external nofollow noopener noreferrer" target="_blank">对象头</a>主要包含两部分数据：Mark Word、Klass Pointer(类型指针，用来确定是哪个类的实例)。</p>
<p><strong>Mark Word</strong>：存储了对象的HashCode、分代年龄和锁标志位信息。对象的状态不同，Mark Word里存储的信息也会不同。</p>
<p><img src="/Wiki/wiki/Java/笔记/image-20190410212710712.png" alt="image-20190410212710712"></p>
<h4 id="锁消除-Lock-Elision"><a href="#锁消除-Lock-Elision" class="headerlink" title="锁消除(Lock Elision)"></a>锁消除(Lock Elision)</h4><p>通过逃逸分析的技术，如果对象只会被一个线程使用，在编译成字节码的时候会去掉不必要的锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getFruits</span> <span class="params">(String... fruits )</span> </span>&#123;</span><br><span class="line">	Vector v = <span class="keyword">new</span> Vector();</span><br><span class="line">	<span class="keyword">for</span> (String fruit: fruits)</span><br><span class="line">	v.add(fruit);</span><br><span class="line">	<span class="keyword">return</span> v.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里v的引用不会逃出getFruits方法，因此Vector的synchronized锁可以去掉。</p>
<h4 id="锁粗化-Lock-Coarsening"><a href="#锁粗化-Lock-Coarsening" class="headerlink" title="锁粗化(Lock Coarsening)"></a>锁粗化(Lock Coarsening)</h4><p>如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Vector <span class="title">getFruits</span><span class="params">(Vector v)</span> </span>&#123;	</span><br><span class="line">	v.add(<span class="string">"Banana"</span>);</span><br><span class="line">	v.add(<span class="string">"Melon"</span>);</span><br><span class="line">	<span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每调一次add方法都有一次获取锁、释放锁的过程，编译器会用一个锁将它们包起来，这个过程叫做锁粗化。对于循环，锁粗化会导致锁长时间被一个线程持有，因此锁粗化只会应用于非循环的情况。</p>
<h4 id="自旋锁与自适应自旋锁"><a href="#自旋锁与自适应自旋锁" class="headerlink" title="自旋锁与自适应自旋锁"></a>自旋锁与自适应自旋锁</h4><p>阻塞或唤醒线程存在上下文切换的代价。因此出现了自旋锁，当发现自旋时间过长时，可以将其转化成重量级锁(即OS层面对锁)，因此称为自适应自旋锁。自旋锁的实现原理是CAS。</p>
<h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><p>大多数时候，不存在锁的竞争。轻量级锁是根据这个场景进行优化。</p>
<ol>
<li>拷贝对象头中的Mark Word到当前线程栈帧中的Lock Record</li>
<li>CAS将Mark Word的ptr指向线程Lock Record</li>
<li>成功则获取到锁，失败则自旋再尝试，自旋达到一定次数后膨胀为重量级锁。</li>
</ol>
<h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>大多数情况，锁总是被同一个线程获得，因此出现了偏向锁。</p>
<p>当锁对象第一次被线程获取时，虚拟机会将对象头中的标志位设为偏向模式，并通过CAS在Mark Word里存储当前线程ID，在线程进入或退出同步代码块时，不是去获取或释放锁，而是检测Mark Word里存储的线程ID是否与当前线程ID相同即可，因此相比自旋锁，偏向锁少了多处CAS的开销。如果相同，说明已经获取到锁，如果不同，说明偏向的是别的线程，这时候就应该撤销偏向锁，不能继续偏向原来的线程。偏向锁的撤销，需要在如下场景下：</p>
<p><img src="/Wiki/wiki/Java/笔记/v2-9db4211af1be81785f6cc51a58ae6054_r.jpg" alt="preview"></p>
<h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><h4 id="volatile作用"><a href="#volatile作用" class="headerlink" title="volatile作用"></a>volatile作用</h4><p>在单核处理中，同一进程的不同线程访问共享数据时，CPU先将共享变量加载到共享缓存中，不同线程访问该数据时，都是访问的同一个地址，因此volatile的可见性就没有必要了。但是在多核处理器中，每个CPU都会从主存中将数据加载到其自身的缓存中，这时候就可能会出现缓存不一致的问题，当多线程运行在不同的CPU时，就可能导致每个线程看到的数据不一致，volatile就是为了解决这个问题。</p>
<p>volatile修饰的变量具有可见性，对一个volatile变量的写操作及这个写操作之前的所有操作Happens-Before对这个变量的读操作及这个读操作之后的所有操作。</p>
<h4 id="volatile实现原理"><a href="#volatile实现原理" class="headerlink" title="volatile实现原理"></a>volatile实现原理</h4><p>volatile需要借助硬件来实现。对volatile变量的写操作，会在正常汇编指令前加一个lock前缀的指令，这个指令在多核处理器会做<a href="http://www.importnew.com/27002.html" rel="external nofollow noopener noreferrer" target="_blank">两件事</a>。</p>
<ol>
<li>锁总线，其它CPU对内存的读写请求都会被阻塞，直到锁释放，由于锁总线期间其他CPU没法访问内存，因此其开销比较大，后来的处理器都采用锁缓存替代锁总线，通过缓存一致性协议来实现数据一致。缓存一致性协议有多种，常见的是通过嗅探来实现，通过不停的嗅探总线上的数据交换，从而当一个缓存代表它所属的处理器去读写内存时，其它处理器都会得到通知，它们以此来使自己的缓存保持同步。</li>
<li>lock后的写操作会回写已修改的数据，同时让其它CPU相关缓存行失效，从而重新从主存中加载最新的数据</li>
</ol>
<h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>每个线程保存一个变量的副本。</p>
<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><ol>
<li><p>方便传参数，A方法到F方法，中间经过了很多方法，现在需要从A多传一个参数到F，为了避免对中间方法对应用，可以用threadlocal来进行传参。</p>
</li>
<li><p>其实应用场景就跟其作用所说一样，需要使用与线程相关的数据时使用。</p>
</li>
</ol>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>已有的条件是什么？:</p>
<p>ThreadLocal变量，线程实例</p>
<p>求解的问题:</p>
<p>ThreadLocal实现原理</p>
<p>每个线程一个变量，通过ThreadLocal的方法获取到该值，很容易想到的就是Map。即线程实例为键，变量为值。那么这个map保存在哪呢？正常想到的想法是保存在ThreadLocal对象里，即ThreadLocal t 有个Map，这个Map保存了线程和其值的关系。但是线程对象大多数是临时对象，也就是说ThreaLocal的这个Map需要经常更新，不然就会保持对线程的引用，导致线程无法回收。既然线程的变量存活周期与线程是一样的，那么何不把这个变量保存在线程对象中呢，由于线程会有不同类型的threadlocal局部变量，因此需要一个字段能够包含这所有的threalocal，做法还是用map，key是ThreadLocal变量，而value是线程真正对应的值。<code>Entry(ThreadLocal&lt;?&gt; k, Object v)</code></p>
<h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><h2 id="JVM内存区域"><a href="#JVM内存区域" class="headerlink" title="JVM内存区域"></a>JVM内存区域</h2><h3 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h3><h2 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h2><p>GC要做的三件事：</p>
<ol>
<li><p><strong>哪些内存需要回收(what)</strong></p>
</li>
<li><p><strong>什么时候回收(when)</strong></p>
</li>
<li><p><strong>怎么回收(how</strong>)</p>
</li>
</ol>
<h4 id="哪些内存需要回收"><a href="#哪些内存需要回收" class="headerlink" title="哪些内存需要回收"></a>哪些内存需要回收</h4><p>可达性分析，GC Roots Tracing：当对象与GC Roots没有引用链相连时，该对象为<strong>不可达对象</strong>。GC Roots包括如下</p>
<ol>
<li>System Class</li>
</ol>
<p>​            由bootstrap/system 类加载器加载的类</p>
<ol start="2">
<li>Native Code</li>
</ol>
<p>​            Native code中的局部变量和全局变量</p>
<ol start="3">
<li>Thread Block</li>
</ol>
<p>​            当前活跃线程里引用的对象</p>
<ol start="4">
<li>Thread</li>
</ol>
<p>​            已启动的线程</p>
<ol start="5">
<li><p>Stack Local</p>
<p>Java方法的local变量或参数 </p>
</li>
</ol>
<p>当一个对象被标记为不可达后，下一个垃圾回收会试图回收该对象，如果对象重写了finalize方法，并且在这个方法自救成功(将自身赋予某个引用)，则不会被回收，但是如果没有重写finalize或者已经执行过该方法，则自救失败。</p>
<p>什么时候回收要与怎么回收一起来看，Java主要采用了分代回收，将堆内存分成了新生代和老年代。</p>
<h4 id="怎么回收"><a href="#怎么回收" class="headerlink" title="怎么回收"></a>怎么回收</h4><p>通过垃圾收集器进行垃圾回收</p>
<p>垃圾回收分为三步：</p>
<ol>
<li><strong>标记</strong>(Mark)</li>
</ol>
<p>要进行垃圾回收，首先要确定哪些是垃圾嘛，这一步将对对象进行扫描，来确定哪些对象需要回收</p>
<ol start="2">
<li><strong>清除</strong></li>
</ol>
<p>既然知道哪些对象要回收，那么这一步就从内存中删掉这些对象</p>
<p><img src="/Wiki/wiki/Java/笔记/clip_image002.png" alt="https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/images/gcslides/Slide1b.png"></p>
<ol start="3">
<li><strong>整理</strong>(compact)</li>
</ol>
<p>如上所示，在清除时会产生内存碎片，可以在清除后进行整理，来清除内存碎片。</p>
<p>在上述步骤中，标记和整理是比较耗时的，随着对象越来越多，垃圾回收的时间也就越长，而实际上，一个应用的大多数对象其实存活时间是很短的，分代回收的思想是不同代的对象存活时间不一样，因此垃圾回收的频率应该也不一样，尽量做到：当开始垃圾回收时，能做到大多数对象被标记为可被回收，使得标记阶段做的活不是白费的。这就是<strong>为什么采用分代回收</strong>。</p>
<p>如图所示</p>
<p><img src="/Wiki/wiki/Java/笔记/clip_image003.png" alt="https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/images/gcslides/Slide5.png">大多数对象最初都被分配到新生代，对新生代里的对象的预期就是存活时间不长，当新生代区域满时，就会发生<strong>minor gc</strong>，当对象在新生代中存活超过一定的gc次数，就会被移动到老年代中，当老年代也需要回收时，此时会发生<strong>full gc。</strong></p>
<p><strong>GC流程如下：</strong></p>
<ol>
<li>对象首先放到eden区，eden区满时，发生minor gc，存活对象移动到S0，清除eden区。同时，对象被标记存活年龄。</li>
</ol>
<p><strong><img src="/Wiki/wiki/Java/笔记/clip_image004.png" alt="img"></strong></p>
<ol start="2">
<li>下一次minor gc时，存活对象和S0的对象移动到S1，清除eden和S0区。</li>
</ol>
<p><strong><img src="/Wiki/wiki/Java/笔记/clip_image005.png" alt="img"></strong></p>
<ol start="3">
<li>下一次，存活对象则从S1到S0，如此反复，当对象存活超过一定次数，移动到老年代。</li>
</ol>
<p><strong><img src="/Wiki/wiki/Java/笔记/clip_image006.png" alt="img"></strong></p>
<p>​            <strong>为什么设置S0、S1</strong>？首先，<strong>为什么需要survivor区</strong>？如果没有survivor区，eden区满了之后就会被送到老年代，这会导致很快发生Full GC。这些对象可能还是属于死得早的对象，只不过逃过了第一次垃圾回收，设置S区作为缓冲区可以使得这些年轻对象仍在年轻代被回收。<strong>为什么需要两个S区</strong>？主要是为了避免内存碎片，如果只有一个，那么在第二次minor gc时，可能eden和survivor区都会有部分对象存活，如果把eden区存活对象放到s区，很明显会产生内存碎片。为了避免内存碎片，新增一个s区，将所有存活对象移动到另一个空的s区中去。</p>
<p>​            <strong>Full GC具体什么时候发生</strong>？前面说到当老年代需要回收时，会触发Full GC。那么什么时候会触发呢，1. 当老年代空间不足时，空间不足包括几种可能：创建大对象、大数组，老年代没有足够大的连续空间时；新生代转入导致空间不足。2.Metaspace空间不足。3.System.gc()方法的调用，这个方法是建议虚拟机进行Full GC，很多时候确实也会导致Full GC。</p>
<p>​            <strong>存活的对象Survivor区放不下怎么办</strong>？如果Survivor区太小，放不下的对象会被直接放到老年代，如果Survivor区太大，则会造成无用的浪费。虚拟机会在每次垃圾回收时设置一个threshold，对象被晋升到老年代时的存活次数，这个值保证survivor区的剩余空间大概在一半左右。</p>
<h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><p>对年轻代和老年代，可以采用不同的垃圾回收算法。</p>
<h4 id="Serial-GC"><a href="#Serial-GC" class="headerlink" title="Serial GC"></a><strong>Serial GC</strong></h4><p>单线程进行垃圾回收，没有线程间通信开销，效率比较高，适用于单处理器的机器。</p>
<p>也适用于一台机器上运行多个JVM(超过处理器数量)的情况，可以避免多线程回收对其他JVM的影响。还适用于对停顿时间要求不是很高的场景。</p>
<h4 id="Parallel-GC"><a href="#Parallel-GC" class="headerlink" title="Parallel GC"></a><strong>Parallel GC</strong></h4><p>并行执行年轻代的垃圾回收，适用于对系统吞吐量要求较高的环境。</p>
<h4 id="Concurrent-GC"><a href="#Concurrent-GC" class="headerlink" title="Concurrent GC"></a><strong>Concurrent GC</strong></h4><p>减少应用的停顿时间。</p>
<p>应用可以对年轻代和老年代配置一组相互兼容的垃圾收集器。如下图所示。</p>
<p><img src="/Wiki/wiki/Java/笔记/clip_image008.png" alt="gc-collectors-pairing"></p>
<p>stop-the-world pause: 只使应用线程全部暂停的垃圾回收。</p>
<p>所有的垃圾回收在minor gc时都会有stop-the-world pause，但是在full gc时，CMS和G1收集器与其他垃圾收集器的区别在于它们可以在标记阶段做到没有停顿，不过代价是占用更多的CPU资源。</p>
<h4 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h4><p>CMS收集器使用一个或多个线程在后台定期对老年代进行回收。但是由于不进行整理操作，会产生内存碎片。</p>
<h4 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h4><p>G1收集器将堆分为了许多region。</p>
<p>堆大小什么时候扩容</p>
<p>MetaSpace大小设置过大导致发生Full GC</p>
<h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><h3 id="线程池的作用"><a href="#线程池的作用" class="headerlink" title="线程池的作用"></a>线程池的作用</h3><ol>
<li>线程的创建和销毁消耗资源，因此通过池技术来达到复用。</li>
<li>对线程进行管控，线程创建无限制的话，对整个系统可能造成致命影响。</li>
<li>根据业务创建线程池，可以对业务进行隔离，避免相互影响。</li>
</ol>
<h3 id="Java线程池"><a href="#Java线程池" class="headerlink" title="Java线程池"></a>Java线程池</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, RejectedExecutionHandler handler)</span><br></pre></td></tr></table></figure>
<p>重要参数</p>
<ul>
<li><code>corePoolSize</code> 池中的线程基本个数</li>
<li><code>maximumPoolSize</code> 最大线程个数</li>
<li><code>keepAliveTime</code> 当线程个数大于<code>corePoolSize</code>时，线程空闲时的最大存活时间</li>
<li><code>workQueue</code> 存放任务的阻塞队列</li>
<li><code>handler</code> 当队列和最大线程池都满了之后的饱和策略。</li>
</ul>
<p>通过<code>threadPool.execute(**new** Job())</code>提交一个任务后，经历如下几个步骤</p>
<p><img src="/Wiki/wiki/Java/笔记/image-20190401131756815.png" alt="image-20190401131756815"></p>
<p>线程池提供了四种拒绝策略，也可以自己实现接口自定义饱和策略：</p>
<p>1、AbortPolicy：直接抛出异常，默认策略；<br>2、CallerRunsPolicy：用调用者所在的线程来执行任务；<br>3、DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务；<br>4、DiscardPolicy：直接丢弃任务；</p>
<p>线程池配置的合理性主要还是需要通过测试验证来确定。基本原则是：线程等待时间所占比例越高，需要越多线程；线程cpu时间所占比例越高，需要越少线程。</p>
<h3 id="Thread-run-和Thread-start-区别"><a href="#Thread-run-和Thread-start-区别" class="headerlink" title="Thread.run()和Thread.start()区别"></a>Thread.run()和Thread.start()区别</h3><p>run方法就是个普通方法，可以被重复调用，不能起到多线程的目的；调用start方法，会启动新的线程，线程获取到时间片后，会运行run方法，<strong>start不能被重复调用，为什么呢</strong>？如果在一个Thread对象执行<a href="https://stackoverflow.com/questions/2663426/why-cant-we-call-the-start-method-twice-on-a-same-instance-of-the-thread-object" rel="external nofollow noopener noreferrer" target="_blank">多次并发操作</a>，那么getStackTrace() and getState()应该返回什么？</p>
<h3 id="创建线程有哪几种方式"><a href="#创建线程有哪几种方式" class="headerlink" title="创建线程有哪几种方式"></a>创建线程有哪几种方式</h3><ol>
<li>实现Runnable接口，重写run<a href="https://juejin.im/post/5aa12936f265da238d504b7c" rel="external nofollow noopener noreferrer" target="_blank">方法</a></li>
<li>继承Thread，重写run方法，Thread实现了Runnable接口，与方法1其实原理一样</li>
<li>实现Callable接口，结合FutureTask使用</li>
</ol>
<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h3 id="解决哈希冲突的方法"><a href="#解决哈希冲突的方法" class="headerlink" title="解决哈希冲突的方法"></a>解决哈希冲突的方法</h3><p>常用方法有开放地址法(Python 字典<a href="https://www.kawabangga.com/posts/2493" rel="external nofollow noopener noreferrer" target="_blank">实现</a>)、拉链法(Java HashMap实现)。<a href="https://www.jianshu.com/p/4d3cb99d7580" rel="external nofollow noopener noreferrer" target="_blank">参考</a></p>
<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h2><p>进程是一个资源的容器，为进程里的所有线程提供共享资源，进程是系统资源分配的单位，线程是系统调度的单位。</p>
<p>线程有自己独立的程序计数器和栈，一个进程内的线程共享地址空间，创建和销毁线程的开销比进程小。线程依赖于进程而存在。</p>
<p>进程间通信比线程间通信要复杂。</p>
<h2 id="多线程和多进程如何选择"><a href="#多线程和多进程如何选择" class="headerlink" title="多线程和多进程如何选择"></a>多线程和多进程如何选择</h2><p>多进程的系统鲁棒性更好，适合于分布式场景，内存地址空间隔离，对于不需要共享数据的情况下，可以使用多进程。</p>
<p>线程创建和销毁的开销小，对于一些服务器响应任务，所需线程数量经常变化的场景适合用多线程，而不适合用多进程。线程间可以共享内存地址空间，这也是需要多线程的原因。</p>
<p>强相关的处理用线程，弱相关的处理用进程。多线程更方便于功能的内聚，更有力的进行资源的共享，多进程更方便于功能的可拆分，但多进程会导致资源共享的困难。需要多任务进行大量CPU计算的适合用多线程，因为线程切换比较快。</p>
<p>可能要扩展到多机分布的用进程，实际应用中都是进程+线程的结合方式</p>
<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="四种隔离级别"><a href="#四种隔离级别" class="headerlink" title="四种隔离级别"></a>四种隔离级别</h2><h3 id="读未提交"><a href="#读未提交" class="headerlink" title="读未提交"></a>读未提交</h3><p>读不会加锁，其他事务在写的时候会加<strong>排它锁</strong>(排它锁会阻止其它事务再对其锁定的数据加读或写的锁，但是对不加锁的读无影响)。</p>
<h3 id="读已提交"><a href="#读已提交" class="headerlink" title="读已提交"></a>读已提交</h3><p>MVCC机制实现，MVCC版本的生成时机是每次select时，因此会出现<strong>不可重复读</strong>现象。</p>
<h3 id="可重复读隔离级别的底层实现"><a href="#可重复读隔离级别的底层实现" class="headerlink" title="可重复读隔离级别的底层实现"></a>可重复读隔离级别的底层实现</h3><p>MVCC机制，一次事务中，只在<strong>第一次select</strong>时生成版本，后续的查询都是在这个版本上进行，从而实现了<strong>可重复读</strong>。但是因为MVCC的快照只对<strong>读操作</strong>有效，对<strong>写操作</strong>无效，举例说明会更清晰一点： 事务A依次执行如下3条sql，事务B在语句1和2之间，插入10条age=20的记录，事务A就<strong>幻读</strong>了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. select count(1) from user where age=20;</span><br><span class="line">-- return 0: 当前没有age=20的</span><br><span class="line">2. update user set name=test where age=20;</span><br><span class="line">-- Affects 10 rows: 因为事务B刚写入10条age=20的记录，而写操作是不受MVCC影响，能看到最新数据的，所以更新成功，而一旦操作成功，这些被操作的数据就会对当前事务可见</span><br><span class="line">3. select count(1) from user where age=20;</span><br><span class="line">-- return 10: 出现幻读</span><br></pre></td></tr></table></figure>
<p>REPEATABLE READ级别，可以防止大部分的幻读，但像前边举例读-写-读的情况，使用不加锁的select依然会幻读。</p>
<h3 id="Serializable"><a href="#Serializable" class="headerlink" title="Serializable"></a>Serializable</h3><p>读加共享锁，写加排他锁，读写互斥。</p>
<h2 id="为什么索引快"><a href="#为什么索引快" class="headerlink" title="为什么索引快"></a>为什么索引快</h2><ol>
<li>索引块的数量比数据块数量少</li>
<li>键被排序，可以使用查找算法高效查找</li>
<li>索引文件可能足够小，以至于可以永久存放在主存缓冲区中</li>
</ol>
<h2 id="哪些情况下不会使用索引"><a href="#哪些情况下不会使用索引" class="headerlink" title="哪些情况下不会使用索引"></a>哪些情况下不会使用索引</h2><ul>
<li>全表扫描比使用索引快，不会使用索引</li>
<li>like是以%开头</li>
<li>潜在的数据类型转换</li>
<li>索引列参与了函数运算</li>
<li>or关键字，其中一个字段没索引</li>
</ul>
<h3 id="B-树和B树的区别"><a href="#B-树和B树的区别" class="headerlink" title="B+树和B树的区别"></a>B+树和B树的区别</h3><p>B树是充分利用磁盘预读功能而创建的一种数据结构，B树的每个节点可以存储多个关键字，它将节点大小设置为磁盘页的大小，充分利用了<strong>磁盘预读</strong>的功能。每次读取磁盘页时就会读取一整个节点。也正因每个节点存储着非常多个关键字，<strong>树的深度就会非常的小</strong>。进而要执行的<strong>磁盘读取操作次数就会非常少</strong>，更多的是在内存中对读取进来的数据进行查找。</p>
<p>B+树的内部节点并没有指向关键字具体信息的指针，因此其内部节点大小比B树小，<strong>同一磁盘块所能容纳的关键字数量也更多</strong>，一次能读入内存中的关键字也就越多，IO读写次数也就降低了。</p>
<p>B+树基于范围的查询更简洁，因为叶子节点有指向下一个叶子节点的指针。</p>
<p>B+树的查询效率更加稳定。任何关键字的查找必须走一条从根结点到叶子结点的路。</p>
<h3 id="CBO"><a href="#CBO" class="headerlink" title="CBO"></a>CBO</h3><p>CBO会从目标sql诸多可能的执行路径中选择一条成本值(消耗的I/O和CPU资源)最小的执行路径来作为其执行计划。</p>
<h4 id="cbo的缺陷"><a href="#cbo的缺陷" class="headerlink" title="cbo的缺陷"></a>cbo的缺陷</h4><p>cbo的缺陷就在于它可能会选错执行计划。</p>
<ol>
<li>解析多表关联的sql时，可能的执行路径太多，不可能全部遍历。</li>
<li>假设sql都是单独执行的，没有考虑缓存。。。。</li>
</ol>
<p>索引全扫描(INDEX FULL SCAN)，扫描目标索引所有叶子块的所有索引行。</p>
<p>走索引全扫描能够达到排序的效果，避免了对该索引的索引键值列的真正排序操作。</p>
<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="如何写好while-loop"><a href="#如何写好while-loop" class="headerlink" title="如何写好while loop"></a>如何写好while loop</h2><p>需要思考如下几点：</p>
<ol>
<li>从上一迭代到下一迭代是怎么转变的，涉及什么数据变化，数据怎么变化</li>
<li>迭代的终止条件是什么</li>
</ol>
<h3 id="uuid的作用，优缺点"><a href="#uuid的作用，优缺点" class="headerlink" title="uuid的作用，优缺点"></a>uuid的作用，优缺点</h3>
            </div>
        
        <footer class="article-footer">
        </footer>
    </div>
</article>


    
<nav id="article-nav">
    
    
        <a href="/Wiki/wiki/Java/HashMap/" id="article-nav-older" class="article-nav-link-wrap">
            <strong class="article-nav-caption">Older</strong>
            <div class="article-nav-title">HashMap</div>
        </a>
    
</nav>





    
    




<!-- baidu url auto push script -->
<script type="text/javascript">
    !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=window.location.href,o=document.referrer;if(!e.test(r)){var n="//api.share.baidu.com/s.gif";o?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var t=new Image;t.src=n}}(window);
</script>     
</section>
        </div>
        <footer id="footer">
    <div class="outer">
        <div id="footer-info" class="inner">
            polyval &copy; 2019 
            <a rel="external nofollow noopener noreferrer" href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-nd/4.0/80x15.png"></a>
            <br> Powered by <a href="http://hexo.io/" target="_blank" rel="external nofollow noopener noreferrer">Hexo</a>. Theme - <a href="https://github.com/zthxxx/hexo-theme-Wikitten" rel="external nofollow noopener noreferrer" target="_blank">wikitten</a>
            
                <br><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span></span> | 
                <span id="busuanzi_container_site_pv"><i class="fa fa-user"><span id="busuanzi_value_site_uv"></span></i></span>
            
        </div>
    </div>
</footer>
        

    
        <script src="/Wiki/libs/lightgallery/js/lightgallery.min.js"></script>
        <script src="/Wiki/libs/lightgallery/js/lg-thumbnail.min.js"></script>
        <script src="/Wiki/libs/lightgallery/js/lg-pager.min.js"></script>
        <script src="/Wiki/libs/lightgallery/js/lg-autoplay.min.js"></script>
        <script src="/Wiki/libs/lightgallery/js/lg-fullscreen.min.js"></script>
        <script src="/Wiki/libs/lightgallery/js/lg-zoom.min.js"></script>
        <script src="/Wiki/libs/lightgallery/js/lg-hash.min.js"></script>
        <script src="/Wiki/libs/lightgallery/js/lg-share.min.js"></script>
        <script src="/Wiki/libs/lightgallery/js/lg-video.min.js"></script>
    
    
        <script src="/Wiki/libs/justified-gallery/jquery.justifiedGallery.min.js"></script>
    
    
        <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true,
            TeX: {
                equationNumbers: {
                  autoNumber: 'AMS'
                }
            }
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script async src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    



<!-- Custom Scripts -->
<script src="/Wiki/js/main.js"></script>

    </div>
</body>
