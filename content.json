{"pages":[{"title":"About","date":"2016-10-24T02:24:00.000Z","path":"about/index.html","text":""},{"title":"Categories","date":"2018-10-11T04:38:40.994Z","path":"categories/index.html","text":""},{"title":"Tags","date":"2018-10-11T04:38:53.591Z","path":"tags/index.html","text":""}],"posts":[{"title":"Linux命令","date":"2018-10-21T05:08:29.000Z","path":"wiki/操作系统/Linux命令/","text":"psps -ef | grep &quot;&quot; zgrepxargsfindfind . -name &quot;&quot; | xargs zgrep &quot;&quot; 查找端口被占用的程序lsof -i :&lt;port&gt;","tags":[],"categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://polyval.github.io/Wiki/categories/操作系统/"}]},{"title":"Spring Cloud","date":"2018-10-21T03:28:21.000Z","path":"wiki/微服务/Spring Cloud/","text":"配置管理服务治理服务注册服务向注册中心登记自己提供的服务 服务发现通过服务名发起请求调用 断路器智能路由","tags":[{"name":"微服务","slug":"微服务","permalink":"http://polyval.github.io/Wiki/tags/微服务/"}],"categories":[{"name":"微服务","slug":"微服务","permalink":"http://polyval.github.io/Wiki/categories/微服务/"}]},{"title":"Git","date":"2018-10-21T03:28:21.000Z","path":"wiki/工具/Git/","text":"原理四大区 工作区(Working Directory) 暂存区(Stage or index) 本地库 远程库 各区的转换图如下 HEADHEAD是一个特殊的指针，指向当前工作分支的最新commit 常用命令cherry-pick再次应用已经存在的commits，可以将其他分支的某些commit应用到当前分支。 git cherry-pick &lt;commit id&gt;git cherry-pick &lt;start-commit-id&gt;^..&lt;end-commit-id&gt;应用这一区段的commits，左闭右闭。 git cherry-pick --abort取消操作 stash在某些分支上进行了改动，但是还没有完成，也没有提交，这个时候又要切到另外一个分支上进行工作。 git stashgit stash listgit stash apply恢复到上次stash的状态 git stash pop恢复到上次stash的状态并去掉上次的stash revert将某些commit回退掉，同时会生成新的commit来记录这次操作 git revert &lt;commit&gt;git revert HEAD~3撤销倒数第四次commit。 reset三种模式 – mixed。回退暂存区，工作区不动。也就是说改动的文件不会动但是会回退到未提交状态。—mixed是默认选项。 – hard。 暂存区和工作区都会被回退掉。 – soft。 暂存区和工作区都不会动，回退到指定的commit之后，这个commit之后的文件都处于changed to be committed状态。 git resetgit add 之后想撤销就可以用这个命令 git reset --hard HEAD~3最近三次提交不想要了，也不想再看到它们。可以使用这个命令。 git reset -- &lt;file&gt;回退单个文件。 reflogref + log reflog命令可以查看所有的历史操作记录 比如误操作用了git reset --hard HEAD^ 这时候用git log是找不到原来的commit的，这时候可以用git reflog找到commit id来进行恢复。 rebase将某个分支的修改移动到当前分支，依次将提交作用到当前分支，作用到过程中生成新的提交记录，提交信息默认与原来的一致。 应用场景","tags":[],"categories":[{"name":"工具","slug":"工具","permalink":"http://polyval.github.io/Wiki/categories/工具/"}]},{"title":"CAP定理","date":"2018-10-21T03:28:21.000Z","path":"wiki/分布式/CAP定理/","text":"CAP定理分布式系统中有三个指标 Consistency 一致性 Avaliability 可用性 Partition tolerance 分区容错 CAP定理认为这三个指标不可能同时做到。 Patition tolerance分区容错指分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务。 Consistency等同于所有节点访问同一份最新的数据副本 Avaliability可用性指“Reads and writes always succeed”，即服务一直可用，而且是正常响应时间。 CAP权衡CAP权衡有三种情况 CA without P这种情况在分布式系统中几乎是不存在的。首先在分布式环境下，网络分区是一个自然的事实。因为分区是必然的，所以如果舍弃P，意味着要舍弃分布式系统。那也就没有必要再讨论CAP理论了。 对于一个分布式系统来说。P是一个基本要求，CAP三者中，只能在CA两者之间做权衡，并且要想尽办法提升P。 CP without A如果一个分布式系统不要求强的可用性，即容许系统停机或者长时间无响应的话，就可以在CAP三者中保障CP而舍弃A。 一个保证了CP而一个舍弃了A的分布式系统，一旦发生网络故障或者消息丢失等情况，就要牺牲用户的体验，等待所有数据全部一致了之后再让用户访问系统。 AP wihtout C要高可用并允许分区，则需放弃一致性。一旦网络问题发生，节点之间可能会失去联系。为了保证高可用，需要在用户访问时可以马上得到返回，则每个节点只能用本地数据提供服务，而这样会导致全局数据的不一致性。 这种舍弃强一致性而保证系统的分区容错性和可用性的场景和案例非常多。前面我们介绍可用性的时候说到过，很多系统在可用性方面会做很多事情来保证系统的全年可用性可以达到N个9，所以，对于很多业务系统来说，比如淘宝的购物，12306的买票。都是在可用性和一致性之间舍弃了一致性而选择可用性。 你在12306买票的时候肯定遇到过这种场景，当你购买的时候提示你是有票的（但是可能实际已经没票了），你也正常的去输入验证码，下单了。但是过了一会系统提示你下单失败，余票不足。这其实就是先在可用性方面保证系统可以正常的服务，然后在数据的一致性方面做了些牺牲，会影响一些用户体验，但是也不至于造成用户流程的严重阻塞。 但是，我们说很多网站牺牲了一致性，选择了可用性，这其实也不准确的。就比如上面的买票的例子，其实舍弃的只是强一致性。退而求其次保证了最终一致性。也就是说，虽然下单的瞬间，关于车票的库存可能存在数据不一致的情况，但是过了一段时间，还是要保证最终一致性的。","tags":[{"name":"分布式","slug":"分布式","permalink":"http://polyval.github.io/Wiki/tags/分布式/"}],"categories":[{"name":"分布式","slug":"分布式","permalink":"http://polyval.github.io/Wiki/categories/分布式/"}]},{"title":"Java分析工具","date":"2018-10-21T03:28:21.000Z","path":"wiki/Java/Java分析工具/","text":"jmap输出对象实例个数jmap -histo &lt;pid&gt; &gt; a.log 查看应用代码实例的个数，对于出现内存泄露的情况，可以快速定位出是哪个对象引起的。 输出堆文件jmap -dump:format=b,file = a.dat &lt;pid&gt; 查看进程堆内存使用情况jmap -heap &lt;pid&gt; jhat查看dump文件jhat -port 9998 /tmp/var/dump.dat 然后在浏览器中输入localhost:9998即可查看 jstackjstat监控GCjstat -gcutil &lt;pid&gt; &lt;interval&gt; &lt;count&gt; jps输出JVM中运行的进程状态信息 jConsolejinfojVisualvmeclipse memory analyzerdump分析工具 BtraceGreys-Anatomy在线问题诊断工具","tags":[{"name":"Java","slug":"Java","permalink":"http://polyval.github.io/Wiki/tags/Java/"}],"categories":[{"name":"Java","slug":"Java","permalink":"http://polyval.github.io/Wiki/categories/Java/"}]},{"title":"Java内存优化","date":"2018-10-21T03:28:21.000Z","path":"wiki/Java/Java内存优化/","text":"常驻内存排查内存泄漏重用对象String.intern()在某服务中，通过与其他进程通讯获取到格式为byte[]的字段，将byte[]转化成String的时候利用new String(byte[])方法，但是string很多是相同的，产生了大量相同的string对象，而且这些对象是程序中当作缓存来用一直存在于内存中，采用String.intern()对String对象进行缓存，降低了内存占用30M。 Integer.valueOf()只需一个实例的对象一定要使用单例对象池技术使用小数据类型减少线程数去垃圾回收机制System.arraycopy ()临时内存减少不必要的对象拷贝，重写对象的clone方法容器大小预估容器在扩容时会产生大量临时对象，对容器大小进行预估传入初始值可以减少容器的扩容","tags":[{"name":"Java","slug":"Java","permalink":"http://polyval.github.io/Wiki/tags/Java/"}],"categories":[{"name":"Java","slug":"Java","permalink":"http://polyval.github.io/Wiki/categories/Java/"}]},{"title":"","date":"2018-10-15T13:36:50.273Z","path":"wiki/Java/TODO/","text":"技能熟悉Java常见问题定位、Python 熟悉React 熟悉Git、Linux常用命令 了解Spring Cloud、微服务、分布式 需求EmlCacheService的内存优化 Java内存分析与优化 MAT堆栈分析 看一下EmlCacheService的线程池怎么用的 String.intern() byte[] 转String用了new String[byte]。无可厚非，但是造成了String的大量重复。 WebTopo专项 CS转BS React WebSocket","tags":[],"categories":[{"name":"Java","slug":"Java","permalink":"http://polyval.github.io/Wiki/categories/Java/"}]},{"title":"","date":"2018-10-14T02:45:25.790Z","path":"wiki/Go/Go语言入门/","text":"GO语言特性协程风格代码风格强制统一public变量必须大写字母开头，private必须小写花括号花括号必须这么写 if expression {…} 不支持函数和操作符重载函数多返回值","tags":[],"categories":[{"name":"Go","slug":"Go","permalink":"http://polyval.github.io/Wiki/categories/Go/"}]},{"title":"","date":"2018-10-07T12:15:41.532Z","path":"wiki/Java/Spring Boot/","text":"Spring Boot简化了构建基于Spring框架的应用的步骤，尤其是简化了spring的配置流程。与我司的云龙平台在创建微服务的时候做的工作类似。","tags":[],"categories":[{"name":"Java","slug":"Java","permalink":"http://polyval.github.io/Wiki/categories/Java/"}]},{"title":"","date":"2018-10-07T05:15:02.544Z","path":"wiki/Java/Netty/","text":"Netty可以简化高性能网络应用程序的开发。Netty是基于Java NIO技术封装的一套框架，提供了一个更易于操作的使用模式和接口。 NIONIO全称是NoneBlocking IO，是一种同步非阻塞等IO模型。区别与BIO，BIO的全称是Blocking IO，阻塞IO。那这个阻塞是什么意思呢？ Accept是阻塞的，只有新连接来了，Accept才会返回，主线程才能继 Read是阻塞的，只有请求消息来了，Read才能返回，子线程才能继续处理 Write是阻塞的，只有客户端把消息收了，Write才能返回，子线程才能继续读取下一个请求 NIO是如何做到非阻塞的它用的是事件机制。它可以用一个线程把Accept，读写操作，请求处理的逻辑全干了。如果什么事都没得做，它也不会死循环，它会将线程休眠起来，直到下一个事件来了再继续干活，这样的一个线程称之为NIO线程。 Linux IO模型网络IO的本质是socket的读取，socket在linux系统被抽象为流，IO可以理解为对流的操作。对于一次IO访问（以read举例），数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。所以说，当一个read操作发生时，它会经历两个阶段： 第一阶段：等待数据准备 (Waiting for the data to be ready)。 第二阶段：将数据从内核拷贝到进程中 (Copying the data from the kernel to the process)。 对于socket流而言， 第一步：通常涉及等待网络上的数据分组到达，然后被复制到内核的某个缓冲区。 第二步：把数据从内核缓冲区复制到应用进程缓冲区。 同步、异步、阻塞、非阻塞概念参考 网络IO的模型大致有如下几种 同步模型（synchronous IO） 阻塞IO（bloking IO） 非阻塞IO（non-blocking IO） 多路复用IO（multiplexing IO） 信号驱动式IO（signal-driven IO） 异步IO（asynchronous IO） 所有的系统I/O都分为两个阶段：等待就绪和操作。举例来说，读函数，分为等待系统可读和真正的读；同理，写函数分为等待网卡可以写和真正的写。 NIO一个重要的特点是：socket主要的读、写、注册和接收函数，在等待就绪阶段都是非阻塞的，真正的I/O操作是同步阻塞的（消耗CPU但性能非常高）。","tags":[],"categories":[{"name":"Java","slug":"Java","permalink":"http://polyval.github.io/Wiki/categories/Java/"}]},{"title":"","date":"2018-10-07T04:51:16.950Z","path":"wiki/Java/Java基础/","text":"静态代码块什么是静态代码块静态代码块用于给类初始化，随类的加载而执行。 静态代码块的作用用于复杂的类静态变量初始化，比如往map里面塞值。","tags":[],"categories":[{"name":"Java","slug":"Java","permalink":"http://polyval.github.io/Wiki/categories/Java/"}]},{"title":"线程状态","date":"2018-10-06T16:28:21.000Z","path":"wiki/Java/线程状态/","text":"线程的状态转换关系 1）BLOCKED：线程等待监视器锁，就是线程在等待获取锁进入同步块或者同步方法中。两个死锁的线程即是Blocked。 2）WAITING： 三种方法可以使线程进入WAITING: Object.wait with no timeout Thread.join with no timeout LockSupport.park 比BLOCKED状态进步一些，指我已经获得锁了，但由于有些条件不满足，我自己等会，调用object.wait()方法。等条件满足了，别的线程调用notify再叫我。另外也可以调用Thread.join()方法，顾名思义就是调用别的线程的join方法，让别人join进来先执行，那我就只能等会了。但是由于wait()和notify()以及notifyAll()用于协调对共享资源的存取，所以必须在synchronized块中使用，即调用wait的时候需要获取锁，调用后锁释放。所以即便wait状态的线程被notfiy唤醒了，也需要再次获得锁，所以唤醒后进入Blocked状态。 3）TIMED_WAITING： 如下方法使线程进入该状态 Thread.sleep Object.wait with timeout Thread.join with timeout LockSupport.parkNanos LockSupport.parkUntil 类比WAITING，差异是不需要notify()或者notifyAlL()方法唤醒，时间到了我自己醒了。另外sleep比较好理解，就是让当前线程睡一会，与wait的区别是它不释放锁。 4）RUNNABLE不用多说，在JAVA虚拟机中已经在运行，但是有可能在等待操作系统资源，比如CPU时间片。 处于Runnable的线程一定消耗cpu么 不一定，比如线程处于io等待，实际上是线程是挂起，不消耗cpu的。 Java线程堆栈解读 tid和nid在采集Java线程堆栈时，有个nid和tid。tid表示Java层面的线程id，是Java给每个线程所分配的一个id，nid(Native thread ID)表示的本地线程id，与实际的操作系统线程id相一致。 堆栈中与锁相关的三种状态 当一个线程占有一个锁的时候，线程堆栈中会打印—locked 当一个线程正在等待其它线程释放该锁，线程堆栈中会打印—waiting to lock 当一个线程占有一个锁，但又执行到该锁的wait()上，线程堆栈中首先打印locked,然后又 会打印—waiting on","tags":[{"name":"Java","slug":"Java","permalink":"http://polyval.github.io/Wiki/tags/Java/"}],"categories":[{"name":"Java","slug":"Java","permalink":"http://polyval.github.io/Wiki/categories/Java/"}]},{"title":"Java内存溢出的情况","date":"2018-10-06T16:28:21.000Z","path":"wiki/Java/Java内存溢出的情况/","text":"1、java.lang.OutOfMemoryError:Java heap spaceJava应用程序在启动时会指定所需要的内存大小，它被分割成两个不同的区域：Heap space（堆空间）和Permgen（永久代）： JVM内存模型示意图 这两个区域的大小可以在JVM（Java虚拟机）启动时通过参数 1-Xmx 和 1-XX:MaxPermSize 设置，如果你没有显式设置，则将使用特定平台的默认值。 当应用程序试图向堆空间添加更多的数据，但堆却没有足够的空间来容纳这些数据时，将会触发java.lang.OutOfMemoryError: Java heap space异常。需要注意的是：即使有足够的物理内存可用，只要达到堆空间设置的大小限制，此异常仍然会被触发。 原因分析触发java.lang.OutOfMemoryError: Java heap space最常见的原因就是应用程序需要的堆空间是XXL号的，但是JVM提供的却是S号。解决方法也很简单，提供更大的堆空间即可。除了前面的因素还有更复杂的成因： 流量/数据量峰值：应用程序在设计之初均有用户量和数据量的限制，某一时刻，当用户数量或数据量突然达到一个峰值，并且这个峰值已经超过了设计之初预期的阈值，那么以前正常的功能将会停止，并触发java.lang.OutOfMemoryError: Java heap space异常。 内存泄漏：特定的编程错误会导致你的应用程序不停的消耗更多的内存，每次使用有内存泄漏风险的功能就会留下一些不能被回收的对象到堆空间中，随着时间的推移，泄漏的对象会消耗所有的堆空间，最终触发java.lang.OutOfMemoryError: Java heap space错误。 示例①、简单示例首先看一个非常简单的示例，下面的代码试图创建2 x 1024 x 1024个元素的整型数组，当你尝试编译并指定12M堆空间运行时（java -Xmx12m OOM）将会失败并抛出java.lang.OutOfMemoryError: Java heap space错误，而当你指定13M堆空间时，将正常的运行。 123456class OOM &#123; static final int SIZE=2*1024*1024; public static void main(String[] a) &#123; int[] i = new int[SIZE]; &#125;&#125; 运行如下： 12345D:\\&gt;javac OOM.javaD:\\&gt;java -Xmx12m OOMException in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space at OOM.main(OOM.java:4)D:\\&gt;java -Xmx13m OOM ②、内存泄漏示例在Java中，当开发者创建一个新对象（比如：new Integer(5)）时，不需要自己开辟内存空间，而是把它交给JVM。在应用程序整个生命周期类，JVM负责检查哪些对象可用，哪些对象未被使用。未使用对象将被丢弃，其占用的内存也将被回收，这一过程被称为垃圾回收。JVM负责垃圾回收的模块集合被称为垃圾回收器（GC）。 Java的内存自动管理机制依赖于GC定期查找未使用对象并删除它们。Java中的内存泄漏是由于GC无法识别一些已经不再使用的对象，而这些未使用的对象一直留在堆空间中，这种堆积最终会导致java.lang.OutOfMemoryError: Java heap space错误。 我们可以非常容易的写出导致内存泄漏的Java代码： 1234567891011121314151617181920212223242526public class KeylessEntry &#123; static class Key &#123; Integer id; Key(Integer id) &#123; this.id = id; &#125; @Override public int hashCode() &#123; return id.hashCode(); &#125; &#125; public static void main(String[] args) &#123; Map&lt;Key,String&gt; m = new HashMap&lt;Key,String&gt;(); while(true) &#123; for(int i=0;i&lt;10000;i++) &#123; if(!m.containsKey(new Key(i))) &#123; m.put(new Key(i), &quot;Number:&quot; + i); &#125; &#125; &#125; &#125;&#125; 代码中HashMap为本地缓存，第一次while循环，会将10000个元素添加到缓存中。后面的while循环中，由于key已经存在于缓存中，缓存的大小将一直会维持在10000。但事实真的如此吗？由于Key实体没有实现equals()方法，导致for循环中每次执行m.containsKey(new Key(i))结果均为false，其结果就是HashMap中的元素将一直增加。 随着时间的推移，越来越多的Key对象进入堆空间且不能被垃圾收集器回收（m为局部变量，GC会认为这些对象一直可用，所以不会回收），直到所有的堆空间被占用，最后抛出java.lang.OutOfMemoryError:Java heap space。 上面的代码直接运行可能很久也不会抛出异常，可以在启动时使用-Xmx参数，设置堆内存大小，或者在for循环后打印HashMap的大小，执行后会发现HashMap的size一直再增长。 解决方法也非常简单，只要Key实现自己的equals方法即可： 12345678Overridepublic boolean equals(Object o) &#123; boolean response = false; if (o instanceof Key) &#123; response = (((Key)o).id).equals(this.id); &#125; return response;&#125; 解决方案第一个解决方案是显而易见的，你应该确保有足够的堆空间来正常运行你的应用程序，在JVM的启动配置中增加如下配置： 1-Xmx1024m 上面的配置分配1024M堆空间给你的应用程序，当然你也可以使用其他单位，比如用G表示GB，K表示KB。下面的示例都表示最大堆空间为1GB： 1234java -Xmx1073741824 com.mycompany.MyClassjava -Xmx1048576k com.mycompany.MyClassjava -Xmx1024m com.mycompany.MyClassjava -Xmx1g com.mycompany.MyClass 然后，更多的时候，单纯地增加堆空间不能解决所有的问题。如果你的程序存在内存泄漏，一味的增加堆空间也只是推迟java.lang.OutOfMemoryError: Java heap space错误出现的时间而已，并未解决这个隐患。除此之外，垃圾收集器在GC时，应用程序会停止运行直到GC完成，而增加堆空间也会导致GC时间延长，进而影响程序的吞吐量。 如果你想完全解决这个问题，那就好好提升自己的编程技能吧，当然运用好Debuggers, profilers, heap dump analyzers等工具，可以让你的程序最大程度的避免内存泄漏问题。 2、java.lang.OutOfMemoryError:GC overhead limit exceeded默认情况下，当应用程序花费超过98%的时间用来做GC并且回收了不到2%的堆内存时，会抛出java.lang.OutOfMemoryError:GC overhead limit exceeded错误。具体的表现就是你的应用几乎耗尽所有可用内存，并且GC多次均未能清理干净。 原因分析java.lang.OutOfMemoryError:GC overhead limit exceeded错误是一个信号，示意你的应用程序在垃圾收集上花费了太多时间但却没有什么卵用。默认超过98%的时间用来做GC却回收了不到2%的内存时将会抛出此错误。那如果没有此限制会发生什么呢？GC进程将被重启，100%的CPU将用于GC，而没有CPU资源用于其他正常的工作。如果一个工作本来只需要几毫秒即可完成，现在却需要几分钟才能完成，我想这种结果谁都没有办法接受。 所以java.lang.OutOfMemoryError:GC overhead limit exceeded也可以看做是一个fail-fast（快速失败）实战的实例。 示例下面的代码初始化一个map并在无限循环中不停的添加键值对，运行后将会抛出GC overhead limit exceeded错误： 123456789public class Wrapper &#123; public static void main(String args[]) throws Exception &#123; Map map = System.getProperties(); Random r = new Random(); while (true) &#123; map.put(r.nextInt(), &quot;value&quot;); &#125; &#125;&#125; 当我们使用如下参数启动程序时： 1java -Xmx100m -XX:+UseParallelGC Wrapper 我们很快就可以看到程序抛出java.lang.OutOfMemoryError: GC overhead limit exceeded错误。但如果在启动时设置不同的堆空间大小或者使用不同的GC算法，比如这样： 1java -Xmx10m -XX:+UseParallelGC Wrapper 我们将看到如下错误： 12345Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space at java.util.Hashtable.rehash(Unknown Source) at java.util.Hashtable.addEntry(Unknown Source) at java.util.Hashtable.put(Unknown Source) at cn.moondev.Wrapper.main(Wrapper.java:12) 使用以下GC算法：-XX:+UseConcMarkSweepGC 或者-XX:+UseG1GC，启动命令如下： 12java -Xmx100m -XX:+UseConcMarkSweepGC Wrapperjava -Xmx100m -XX:+UseG1GC Wrapper 得到的结果是这样的： 12Exception: java.lang.OutOfMemoryError thrown from the UncaughtExceptionHandler in thread &quot;main&quot; 错误已经被默认的异常处理程序捕获，并且没有任何错误的堆栈信息输出。 以上这些变化可以说明，在资源有限的情况下，你根本无法无法预测你的应用是怎样挂掉的，什么时候会挂掉，所以在开发时，你不能仅仅保证自己的应用程序在特定的环境下正常运行。 解决方案首先是一个毫无诚意的解决方案，如果你仅仅是不想看到java.lang.OutOfMemoryError:GC overhead limit exceeded的错误信息，可以在应用程序启动时添加如下JVM参数： 1-XX:-UseGCOverheadLimit 但是强烈建议不要使用这个选项，因为这样并没有解决任何问题，只是推迟了错误出现的时间，错误信息也变成了我们更熟悉的java.lang.OutOfMemoryError: Java heap space而已。 另一个解决方案，如果你的应用程序确实内存不足，增加堆内存会解决GC overhead limit问题，就如下面这样，给你的应用程序1G的堆内存： 1java -Xmx1024m com.yourcompany.YourClass 但如果你想确保你已经解决了潜在的问题，而不是掩盖java.lang.OutOfMemoryError: GC overhead limit exceeded错误，那么你不应该仅止步于此。你要记得还有profilers和memory dump analyzers这些工具，你需要花费更多的时间和精力来查找问题。还有一点需要注意，这些工具在Java运行时有显著的开销，因此不建议在生产环境中使用。 3、java.lang.OutOfMemoryError:Permgen spaceJava中堆空间是JVM管理的最大一块内存空间，可以在JVM启动时指定堆空间的大小，其中堆被划分成两个不同的区域：新生代（Young）和老年代（Tenured），新生代又被划分为3个区域：Eden、From Survivor、To Survivor java.lang.OutOfMemoryError: PermGen space错误就表明持久代所在区域的内存已被耗尽。 原因分析要理解java.lang.OutOfMemoryError: PermGen space出现的原因，首先需要理解Permanent Generation Space的用处是什么。持久代主要存储的是每个类的信息，比如：类加载器引用、运行时常量池（所有常量、字段引用、方法引用、属性）、字段(Field)数据、方法(Method)数据、方法代码、方法字节码等等。我们可以推断出，PermGen的大小取决于被加载类的数量以及类的大小。 因此，我们可以得出出现java.lang.OutOfMemoryError: PermGen space错误的原因是：太多的类或者太大的类被加载到permanent generation（持久代）。 示例①、最简单的示例正如前面所描述的，PermGen的使用与加载到JVM类的数量有密切关系，下面是一个最简单的示例： 12345678910111213import javassist.ClassPool;public class MicroGenerator &#123; public static void main(String[] args) throws Exception &#123; for (int i = 0; i &lt; 100_000_000; i++) &#123; generate(&quot;cn.moondev.User&quot; + i); &#125; &#125; public static Class generate(String name) throws Exception &#123; ClassPool pool = ClassPool.getDefault(); return pool.makeClass(name).toClass(); &#125;&#125; 运行时请设置JVM参数：-XX:MaxPermSize=5m，值越小越好。需要注意的是JDK8已经完全移除持久代空间，取而代之的是元空间（Metaspace），所以示例最好的JDK1.7或者1.6下运行。 代码在运行时不停的生成类并加载到持久代中，直到撑满持久代内存空间，最后抛出java.lang.OutOfMemoryError:Permgen space。代码中类的生成使用了javassist库。 ②、Redeploy-time更复杂和实际的一个例子就是Redeploy（重新部署，你可以想象一下你开发时，点击eclipse的reploy按钮或者使用idea时按ctrl + F5时的过程）。在从服务器卸载应用程序时，当前的classloader以及加载的class在没有实例引用的情况下，持久代的内存空间会被GC清理并回收。如果应用中有类的实例对当前的classloader的引用，那么Permgen区的class将无法被卸载，导致Permgen区的内存一直增加直到出现Permgen space错误。 不幸的是，许多第三方库以及糟糕的资源处理方式（比如：线程、JDBC驱动程序、文件系统句柄）使得卸载以前使用的类加载器变成了一件不可能的事。反过来就意味着在每次重新部署过程中，应用程序所有的类的先前版本将仍然驻留在Permgen区中，你的每次部署都将生成几十甚至几百M的垃圾。 就以线程和JDBC驱动来说说。很多人都会使用线程来处理一下周期性或者耗时较长的任务，这个时候一定要注意线程的生命周期问题，你需要确保线程不能比你的应用程序活得还长。否则，如果应用程序已经被卸载，线程还在继续运行，这个线程通常会维持对应用程序的classloader的引用，造成的结果就不再多说。多说一句，开发者有责任处理好这个问题，特别是如果你是第三方库的提供者的话，一定要提供线程关闭接口来处理清理工作。 让我们想象一个使用JDBC驱动程序连接到关系数据库的示例应用程序。当应用程序部署到服务器上的时：服务器创建一个classloader实例来加载应用所有的类（包含相应的JDBC驱动）。根据JDBC规范，JDBC驱动程序（比如：com.mysql.jdbc.Driver）会在初始化时将自己注册到java.sql.DriverManager中。该注册过程中会将驱动程序的一个实例存储在DriverManager的静态字段内，代码可以参考： 12345678910111213141516171819202122232425// com.mysql.jdbc.Driver源码package com.mysql.jdbc;public class Driver extends NonRegisteringDriver implements java.sql.Driver &#123; public Driver() throws SQLException &#123; &#125; static &#123; try &#123; DriverManager.registerDriver(new Driver()); &#125; catch (SQLException var1) &#123; throw new RuntimeException(&quot;Can\\&apos;t register driver!&quot;); &#125; &#125;&#125;// // // // // // // // // //// 再看下DriverManager对应代码private final static CopyOnWriteArrayList&lt;DriverInfo&gt; registeredDrivers = new CopyOnWriteArrayList&lt;&gt;();public static synchronized void registerDriver(java.sql.Driver driver,DriverAction da) throws SQLException &#123; if(driver != null) &#123; registeredDrivers.addIfAbsent(new DriverInfo(driver, da)); &#125; else &#123; throw new NullPointerException(); &#125;&#125; 现在，当从服务器上卸载应用程序的时候，java.sql.DriverManager仍将持有那个驱动程序的引用，进而持有用于加载应用程序的classloader的一个实例的引用。这个classloader现在仍然引用着应用程序的所有类。如果此程序启动时需要加载2000个类，占用约10MB永久代（PermGen）内存，那么只需要5~10次重新部署，就会将默认大小的永久代（PermGen）塞满，然后就会触发java.lang.OutOfMemoryError: PermGen space错误并崩溃。 解决方案① 解决初始化时的OutOfMemoryError当在应用程序启动期间触发由于PermGen耗尽引起的OutOfMemoryError时，解决方案很简单。 应用程序需要更多的空间来加载所有的类到PermGen区域，所以我们只需要增加它的大小。 为此，请更改应用程序启动配置，并添加（或增加，如果存在）-XX：MaxPermSize参数，类似于以下示例： 1java -XX:MaxPermSize=512m com.yourcompany.YourClass ② 解决Redeploy时的OutOfMemoryError分析dump文件：首先，找出引用在哪里被持有；其次，给你的web应用程序添加一个关闭的hook，或者在应用程序卸载后移除引用。你可以使用如下命令导出dump文件： 1jmap -dump:format=b,file=dump.hprof &lt;process-id&gt; 如果是你自己代码的问题请及时修改，如果是第三方库，请试着搜索一下是否存在”关闭”接口，如果没有给开发者提交一个bug或者issue吧。 ③ 解决运行时OutOfMemoryError首先你需要检查是否允许GC从PermGen卸载类，JVM的标准配置相当保守，只要类一创建，即使已经没有实例引用它们，其仍将保留在内存中，特别是当应用程序需要动态创建大量的类但其生命周期并不长时，允许JVM卸载类对应用大有助益，你可以通过在启动脚本中添加以下配置参数来实现： 1-XX:+CMSClassUnloadingEnabled 默认情况下，这个配置是未启用的，如果你启用它，GC将扫描PermGen区并清理已经不再使用的类。但请注意，这个配置只在UseConcMarkSweepGC的情况下生效，如果你使用其他GC算法，比如：ParallelGC或者Serial GC时，这个配置无效。所以使用以上配置时，请配合： 1-XX:+UseConcMarkSweepGC 如果你已经确保JVM可以卸载类，但是仍然出现内存溢出问题，那么你应该继续分析dump文件，使用以下命令生成dump文件： 1jmap -dump:file=dump.hprof,format=b &lt;process-id&gt; 当你拿到生成的堆转储文件，并利用像Eclipse Memory Analyzer Toolkit这样的工具来寻找应该卸载却没被卸载的类加载器，然后对该类加载器加载的类进行排查，找到可疑对象，分析使用或者生成这些类的代码，查找产生问题的根源并解决它。 4、java.lang.OutOfMemoryError:Metaspace前文已经提过，PermGen区域用于存储类的名称和字段，类的方法，方法的字节码，常量池，JIT优化等，但从Java8开始，Java中的内存模型发生了重大变化：引入了称为Metaspace的新内存区域，而删除了PermGen区域。请注意：不是简单的将PermGen区所存储的内容直接移到Metaspace区，PermGen区中的某些部分，已经移动到了普通堆里面。 原因分析Java8做出如此改变的原因包括但不限于： 应用程序所需要的PermGen区大小很难预测，设置太小会触发PermGen OutOfMemoryError错误，过度设置导致资源浪费。 提升GC性能，在HotSpot中的每个垃圾收集器需要专门的代码来处理存储在PermGen中的类的元数据信息。从PermGen分离类的元数据信息到Metaspace，由于Metaspace的分配具有和Java Heap相同的地址空间，因此Metaspace和Java Heap可以无缝的管理，而且简化了FullGC的过程，以至将来可以并行的对元数据信息进行垃圾收集，而没有GC暂停。 支持进一步优化，比如：G1并发类的卸载，也算为将来做准备吧 正如你所看到的，元空间大小的要求取决于加载的类的数量以及这种类声明的大小。 所以很容易看到java.lang.OutOfMemoryError: Metaspace主要原因：太多的类或太大的类加载到元空间。 示例正如上文中所解释的，元空间的使用与加载到JVM中的类的数量密切相关。 下面的代码是最简单的例子： 12345678910public class Metaspace &#123; static javassist.ClassPool cp = javassist.ClassPool.getDefault(); public static void main(String[] args) throws Exception&#123; for (int i = 0; ; i++) &#123; Class c = cp.makeClass(&quot;eu.plumbr.demo.Generated&quot; + i).toClass(); System.out.println(i); &#125; &#125;&#125; 程序运行中不停的生成新类，所有的这些类的定义将被加载到Metaspace区，直到空间被完全占用并且抛出java.lang.OutOfMemoryError:Metaspace。当使用-XX：MaxMetaspaceSize = 32m启动时，大约加载30000多个类时就会死机。 1234567893102331024Exception in thread &quot;main&quot; javassist.CannotCompileException: by java.lang.OutOfMemoryError: Metaspace at javassist.ClassPool.toClass(ClassPool.java:1170) at javassist.ClassPool.toClass(ClassPool.java:1113) at javassist.ClassPool.toClass(ClassPool.java:1071) at javassist.CtClass.toClass(CtClass.java:1275) at cn.moondev.book.Metaspace.main(Metaspace.java:12) ..... 解决方案第一个解决方案是显而易见的，既然应用程序会耗尽内存中的Metaspace区空间，那么应该增加其大小，更改启动配置增加如下参数： 12// 告诉JVM：Metaspace允许增长到512，然后才能抛出异常-XX：MaxMetaspaceSize = 512m 另一个方法就是删除此参数来完全解除对Metaspace大小的限制（默认是没有限制的）。默认情况下，对于64位服务器端JVM，MetaspaceSize默认大小是21M（初始限制值），一旦达到这个限制值，FullGC将被触发进行类卸载，并且这个限制值将会被重置，新的限制值依赖于Metaspace的剩余容量。如果没有足够空间被释放，这个限制值将会上升，反之亦然。在技术上Metaspace的尺寸可以增长到交换空间，而这个时候本地内存分配将会失败（更具体的分析，可以参考：Java PermGen 去哪里了?）。 你可以通过修改各种启动参数来“快速修复”这些内存溢出错误，但你需要正确区分你是否只是推迟或者隐藏了java.lang.OutOfMemoryError的症状。如果你的应用程序确实存在内存泄漏或者本来就加载了一些不合理的类，那么所有这些配置都只是推迟问题出现的时间而已，实际也不会改善任何东西。 5、java.lang.OutOfMemoryError:Unable to create new native thread一个思考线程的方法是将线程看着是执行任务的工人，如果你只有一个工人，那么他同时只能执行一项任务，但如果你有十几个工人，就可以同时完成你几个任务。就像这些工人都在物理世界，JVM中的线程完成自己的工作也是需要一些空间的 出现java.lang.OutOfMemoryError:Unable to create new native thread就意味着Java应用程序已达到其可以启动线程数量的极限了。 原因分析当JVM向OS请求创建一个新线程时，而OS却无法创建新的native线程时就会抛出Unable to create new native thread错误。一台服务器可以创建的线程数依赖于物理配置和平台，建议运行下文中的示例代码来测试找出这些限制。总体上来说，抛出此错误会经过以下几个阶段： 运行在JVM内的应用程序请求创建一个新的线程 JVM向OS请求创建一个新的native线程 OS尝试创建一个新的native线程，这时需要分配内存给新的线程 OS拒绝分配内存给线程，因为32位Java进程已经耗尽内存地址空间（2-4GB内存地址已被命中）或者OS的虚拟内存已经完全耗尽 Unable to create new native thread错误将被抛出 示例下面的示例不能的创建并启动新的线程。当代码运行时，很快达到OS的线程数限制，并抛出Unable to create new native thread错误。 123456789while(true)&#123; new Thread(new Runnable()&#123; public void run() &#123; try &#123; Thread.sleep(10000000); &#125; catch(InterruptedException e) &#123; &#125; &#125; &#125;).start();&#125; 解决方案有时，你可以通过在OS级别增加线程数限制来绕过这个错误。如果你限制了JVM可在用户空间创建的线程数，那么你可以检查并增加这个限制： 123// macOS 10.12上执行$ ulimit -u709 当你的应用程序产生成千上万的线程，并抛出此异常，表示你的程序已经出现了很严重的编程错误，我不觉得应该通过修改参数来解决这个问题，不管是OS级别的参数还是JVM启动参数。更可取的办法是分析你的应用是否真的需要创建如此多的线程来完成任务？是否可以使用线程池或者说线程池的数量是否合适？是否可以更合理的拆分业务来实现….. 6、java.lang.OutOfMemoryError:Out of swap space?Java应用程序在启动时会指定所需要的内存大小，可以通过-Xmx和其他类似的启动参数来指定。在JVM请求的总内存大于可用物理内存的情况下，操作系统会将内存中的数据交换到磁盘上去。 Out of swap space?表示交换空间也将耗尽，并且由于缺少物理内存和交换空间，再次尝试分配内存也将失败。 原因分析当应用程序向JVM native heap请求分配内存失败并且native heap也即将耗尽时，JVM会抛出Out of swap space错误。该错误消息中包含分配失败的大小（以字节为单位）和请求失败的原因。 Native Heap Memory是JVM内部使用的Memory，这部分的Memory可以通过JDK提供的JNI的方式去访问，这部分Memory效率很高，但是管理需要自己去做，如果没有把握最好不要使用，以防出现内存泄露问题。JVM 使用Native Heap Memory用来优化代码载入（JTI代码生成），临时对象空间申请，以及JVM内部的一些操作。 这个问题往往发生在Java进程已经开始交换的情况下，现代的GC算法已经做得足够好了，当时当面临由于交换引起的延迟问题时，GC暂停的时间往往会让大多数应用程序不能容忍。 java.lang.OutOfMemoryError:Out of swap space?往往是由操作系统级别的问题引起的，例如： 操作系统配置的交换空间不足。 系统上的另一个进程消耗所有内存资源。 还有可能是本地内存泄漏导致应用程序失败，比如：应用程序调用了native code连续分配内存，但却没有被释放。 解决方案解决这个问题有几个办法，通常最简单的方法就是增加交换空间，不同平台实现的方式会有所不同，比如在Linux下可以通过如下命令实现： 123456# 原作者使用，由于我手里并没有Linux环境，所以并未测试# 创建并附加一个大小为640MB的新交换文件swapoff -a dd if=/dev/zero of=swapfile bs=1024 count=655360mkswap swapfileswapon swapfile Java GC会扫描内存中的数据，如果是对交换空间运行垃圾回收算法会使GC暂停的时间增加几个数量级，因此你应该慎重考虑使用上文增加交换空间的方法。 如果你的应用程序部署在JVM需要同其他进程激烈竞争获取资源的物理机上，建议将服务隔离到单独的虚拟机中 但在许多情况下，您唯一真正可行的替代方案是： 升级机器以包含更多内存 优化应用程序以减少其内存占用 当您转向优化路径时，使用内存转储分析程序来检测内存中的大分配是一个好的开始。 7、java.lang.OutOfMemoryError:Requested array size exceeds VM limitJava对应用程序可以分配的最大数组大小有限制。不同平台限制有所不同，但通常在1到21亿个元素之间。 当你遇到Requested array size exceeds VM limit错误时，意味着你的应用程序试图分配大于Java虚拟机可以支持的数组。 原因分析该错误由JVM中的native code抛出。 JVM在为数组分配内存之前，会执行特定于平台的检查：分配的数据结构是否在此平台中是可寻址的。 你很少见到这个错误是因为Java数组的索引是int类型。 Java中的最大正整数为2 ^ 31 - 1 = 2,147,483,647。 并且平台特定的限制可以非常接近这个数字，例如：我的环境上(64位macOS，运行Jdk1.8)可以初始化数组的长度高达2,147,483,645（Integer.MAX_VALUE-2）。如果再将数组的长度增加1到Integer.MAX_VALUE-1会导致熟悉的OutOfMemoryError： 1Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Requested array size exceeds VM limit 但是，在使用OpenJDK 6的32位Linux上，在分配具有大约11亿个元素的数组时，您将遇到Requested array size exceeded VM limit的错误。 要理解你的特定环境的限制，运行下文中描述的小测试程序。 示例12345678for (int i = 3; i &gt;= 0; i--) &#123; try &#123; int[] arr = new int[Integer.MAX_VALUE-i]; System.out.format(&quot;Successfully initialized an array with %,d elements.\\n&quot;, Integer.MAX_VALUE-i); &#125; catch (Throwable t) &#123; t.printStackTrace(); &#125;&#125; 该示例重复四次，并在每个回合中初始化一个长原语数组。 该程序尝试初始化的数组的大小在每次迭代时增加1，最终达到Integer.MAX_VALUE。 现在，当使用Hotspot 7在64位Mac OS X上启动代码片段时，应该得到类似于以下内容的输出： 12345678java.lang.OutOfMemoryError: Java heap space at eu.plumbr.demo.ArraySize.main(ArraySize.java:8)java.lang.OutOfMemoryError: Java heap space at eu.plumbr.demo.ArraySize.main(ArraySize.java:8)java.lang.OutOfMemoryError: Requested array size exceeds VM limit at eu.plumbr.demo.ArraySize.main(ArraySize.java:8)java.lang.OutOfMemoryError: Requested array size exceeds VM limit at eu.plumbr.demo.ArraySize.main(ArraySize.java:8) 注意，在出现Requested array size exceeded VM limit之前，出现了更熟悉的java.lang.OutOfMemoryError: Java heap space。 这是因为初始化2 ^ 31-1个元素的数组需要腾出8G的内存空间，大于JVM使用的默认值。 解决方案java.lang.OutOfMemoryError:Requested array size exceeds VM limit可能会在以下任一情况下出现： 数组增长太大，最终大小在平台限制和Integer.MAX_INT之间 你有意分配大于2 ^ 31-1个元素的数组 在第一种情况下，检查你的代码库，看看你是否真的需要这么大的数组。也许你可以减少数组的大小，或者将数组分成更小的数据块，然后分批处理数据。 在第二种情况下，记住Java数组是由int索引的。因此，当在平台中使用标准数据结构时，数组不能超过2 ^ 31-1个元素。事实上，在编译时就会出错：error：integer number too large。 8、Out of memory:Kill process or sacrifice child为了理解这个错误，我们需要补充一点操作系统的基础知识。操作系统是建立在进程的概念之上，这些进程在内核中作业，其中有一个非常特殊的进程，名叫“内存杀手（Out of memory killer）”。当内核检测到系统内存不足时，OOM killer被激活，然后选择一个进程杀掉。哪一个进程这么倒霉呢？选择的算法和想法都很朴实：谁占用内存最多，谁就被干掉。如果你对OOM Killer感兴趣的话，建议你阅读参考资料2中的文章。 当可用虚拟虚拟内存(包括交换空间)消耗到让整个操作系统面临风险时，就会产生Out of memory:Kill process or sacrifice child错误。在这种情况下，OOM Killer会选择“流氓进程”并杀死它。 原因分析默认情况下，Linux内核允许进程请求比系统中可用内存更多的内存，但大多数进程实际上并没有使用完他们所分配的内存。这就跟现实生活中的宽带运营商类似，他们向所有消费者出售一个100M的带宽，远远超过用户实际使用的带宽，一个10G的链路可以非常轻松的服务100个(10G/100M)用户，但实际上宽带运行商往往会把10G链路用于服务150人或者更多，以便让链路的利用率更高，毕竟空闲在那儿也没什么意义。 Linux内核采用的机制跟宽带运营商差不多，一般情况下都没有问题，但当大多数应用程序都消耗完自己的内存时，麻烦就来了，因为这些应用程序的内存需求加起来超出了物理内存（包括 swap）的容量，内核（OOM killer）必须杀掉一些进程才能腾出空间保障系统正常运行。就如同上面的例子中，如果150人都占用100M的带宽，那么总的带宽肯定超过了10G这条链路能承受的范围。 示例当你在Linux上运行如下代码： 12345678910public static void main(String[] args)&#123; List&lt;int[]&gt; l = new java.util.ArrayList(); for (int i = 10000; i &lt; 100000; i++) &#123; try &#123; l.add(new int[100000000]); &#125; catch (Throwable t) &#123; t.printStackTrace(); &#125; &#125;&#125; 在Linux的系统日志中/var/log/kern.log会出现以下日志： 12Jun 4 07:41:59 plumbr kernel: [70667120.897649] Out of memory: Kill process 29957 (java) score 366 or sacrifice childJun 4 07:41:59 plumbr kernel: [70667120.897701] Killed process 29957 (java) total-vm:2532680kB, anon-rss:1416508kB, file-rss:0kB 注意：你可能需要调整交换文件和堆大小，否则你将很快见到熟悉的Java heap space异常。在原作者的测试用例中，使用-Xmx2g指定的2g堆，并具有以下交换配置： 12345# 注意：原作者使用，由于我手里并没有Linux环境，所以并未测试swapoff -a dd if=/dev/zero of=swapfile bs=1024 count=655360mkswap swapfileswapon swapfile 解决方案解决这个问题最有效也是最直接的方法就是升级内存，其他方法诸如：调整OOM Killer配置、水平扩展应用，将内存的负载分摊到若干小实例上….. 我们不建议的做法是增加交换空间，具体原因已经在前文说过。参考资料②中详细的介绍了怎样微调OOM Killer配置以及OOM Killer选择进程算法的实现，建议你参考阅读。 参考资料：① 想要了解更多PermGen与Metaspace的内容推荐你阅读： Java 8会解决PermGen OutOfMemoryError问题吗? Java PermGen 去哪里了? ② 如果你对OOM Killer感兴趣的话，强烈建议你阅读这篇文章： 理解和配置 Linux 下的 OOM Killer","tags":[{"name":"Java","slug":"Java","permalink":"http://polyval.github.io/Wiki/tags/Java/"}],"categories":[{"name":"Java","slug":"Java","permalink":"http://polyval.github.io/Wiki/categories/Java/"}]},{"title":"什么是Java内存模型","date":"2018-10-06T16:28:21.000Z","path":"wiki/Java/什么是Java内存模型/","text":"什么是Java内存模型Java内存模型定义了Java虚拟机与计算机内存的工作方式。Java虚拟机是计算机的模型，这个计算机模型自然包括了内存模型，即Java内存模型。 Java内存模型描述了Java线程与内存的交互方式，它屏蔽了各种硬件和操作系统的访问差异，保证了Java程序在各平台下对内存的访问都能保持效果一致。解决由于多线程通过共享内存进行通信时，存在的本地内存数据不一致、编译器会对代码指令重排序、处理器会对代码乱序执行等带来的问题。目的是保证并发编程场景中的原子性、可见性和有序性。 Java内存模型规定了 所有的变量都存储在主内存中，每条线程还有自己的工作内存，线程的工作内存中保存了该线程中用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递均需要自己的工作内存和主存之间进行数据同步进行。 Java内存模型定义了Java线程与内存的交互方式，在Java语言层面，提供了volatile、synchronized、final等关键字来描述程序多线程行为，而Java内存模型则定义了这些关键字的行为。 支撑Java内存模型的基本原理指令重排序在执行程序时，为了提高性能，编译器和处理器会对指令做重排序。但是，JMM确保在不同的编译器和不同的处理器平台之上，通过插入特定类型的Memory Barrier来禁止特定类型的编译器重排序和处理器重排序，为上层提供一致的内存可见性保证。 Happens-Before原则先抛一个问题：当一个多线程共享变量被某个线程修改后，如何让这个修改被需要读取这个变量的线程感知到。 JMM定义了Happens-Before原则。只要我们理解了Happens-Before原则，无需了解JVM底层的内存操作，就可以利用Happens-Before原则来解决并发编程中的变量可见性问题，也可以理解什么时候变量对其他线程是可见的。 JMM定义的Happens-Before原则是一组偏序关系：对于两个操作A和B，这两个操作可以在不同的线程中执行。如果A Happens-Before B，那么可以保证，当A操作执行完后，A操作的执行结果对B操作是可见的。 Happens-Before的规则包括： 程序顺序规则 锁定规则 volatile变量规则 线程启动规则 线程结束规则 中断规则 终结器规则 传递性规则 下面我们将详细讲述这8条规则的具体内容。 程序顺序规则在一个线程内部，按照程序代码的书写顺序，书写在前面的代码操作Happens-Before书写在后面的代码操作。这时因为Java语言规范要求JVM在单个线程内部要维护类似严格串行的语义，如果多个操作之间有先后依赖关系，则不允许对这些操作进行重排序。 锁定规则对锁M解锁之前的所有操作Happens-Before对锁M加锁之后的所有操作。 1234567891011class HappensBeforeLock &#123; private int value = 0; public synchronized void setValue(int value) &#123; this.value = value; &#125; public synchronized int getValue() &#123; return value; &#125;&#125; 上面这段代码，setValue和getValue两个方法共享同一个监视器锁。假设setValue方法在线程A中执行，getValue方法在线程B中执行。setValue方法会先对value变量赋值，然后释放锁。getValue方法会先获取到同一个锁后，再读取value的值。所以根据锁定原则，线程A中对value变量的修改，可以被线程B感知到。如果这个两个方法上没有synchronized声明，则在线程A中执行setValue方法对value赋值后，线程B中getValue方法返回的value值并不能保证是最新值。本条锁定规则对显示锁(ReentrantLock)和内置锁(synchronized)在加锁和解锁等操作上有着相同的内存语义。对于锁定原则，可以像下面这样去理解：同一时刻只能有一个线程执行锁中的操作，所以锁中的操作被重排序外界是不关心的，只要最终结果能被外界感知到就好。除了重排序，剩下影响变量可见性的就是CPU缓存了。在锁被释放时，A线程会把释放锁之前所有的操作结果同步到主内存中，而在获取锁时，B线程会使自己CPU的缓存失效，重新从主内存中读取变量的值。这样，A线程中的操作结果就会被B线程感知到了。 volatile变量规则对一个volatile变量的写操作及这个写操作之前的所有操作Happens-Before对这个变量的读操作及这个读操作之后的所有操作。 123456789101112131415161718Map configOptions;char[] configText; //线程间共享变量，用于保存配置信息// 此变量必须定义为volatilevolatile boolean initialized = false;// 假设以下代码在线程A中执行// 模拟读取配置信息，当读取完成后将initialized设置为true以通知其他线程配置可用configOptions = new HashMap();configText = readConfigFile(fileName);processConfigOptions(configText, configOptions);initialized = true;// 假设以下代码在线程B中执行// 等待initialized为true，代表线程A已经把配置信息初始化完成while (!initialized) &#123; sleep();&#125;//使用线程A中初始化好的配置信息doSomethingWithConfig(); 上面这段代码，读取配置文件的操作和使用配置信息的操作分别在两个不同的线程A、B中执行，两个线程通过共享变量configOptions传递配置信息，并通过共享变量initialized作为初始化是否完成的通知。initialized变量被声明为volatile类型的，根据volatile变量规则，volatile变量的写入操作Happens-Before对这个变量的读操作，所以在线程A中将变量initialized设为true，线程B中是可以感知到这个修改操作的。但是更牛逼的是，volatile变量不仅可以保证自己的变量可见性，还能保证书写在volatile变量写操作之前的操作对其它线程的可见性。考虑这样一种情况，如果volatile变量仅能保证自己的变量可见性，那么当线程B感知到initialized已经变成true然后执行doSomethingWithConfig操作时，可能无法获取到configOptions最新值而导致操作结果错误。所以volatile变量不仅可以保证自己的变量可见性，还能保证书写在volatile变量写操作之前的操作Happens-Before书写在volatile变量读操作之后的那些操作。可以这样理解volatile变量的写入和读取操作流程：首先，volatile变量的操作会禁止与其它普通变量的操作进行重排序，例如上面代码中会禁止initialized = true与它上面的两行代码进行重排序(但是它上面的代码之间是可以重排序的)，否则会导致程序结果错误。volatile变量的写操作就像是一条基准线，到达这条线之后，不管之前的代码有没有重排序，反正到达这条线之后，前面的操作都已完成并生成好结果。然后，在volatile变量写操作发生后，A线程会把volatile变量本身和书写在它之前的那些操作的执行结果一起同步到主内存中。最后，当B线程读取volatile变量时，B线程会使自己的CPU缓存失效，重新从主内存读取所需变量的值，这样无论是volatile本身，还是书写在volatile变量写操作之前的那些操作结果，都能让B线程感知到，也就是上面程序中的initialized和configOptions变量的最新值都可以让线程B感知到。原子变量与volatile变量在读操作和写操作上有着相同的语义。 线程启动规则Thread对象的start方法及书写在start方法前面的代码操作Happens-Before此线程的每一个动作。start方法和新线程中的动作一定是在两个不同的线程中执行。线程启动规则可以这样去理解：调用start方法时，会将start方法之前所有操作的结果同步到主内存中，新线程创建好后，需要从主内存获取数据。这样在start方法调用之前的所有操作结果对于新创建的线程都是可见的。 线程终止规则线程中的任何操作都Happens-Before其它线程检测到该线程已经结束。这个说法有些抽象，下面举例子对其进行说明。假设两个线程s、t。在线程s中调用t.join()方法。则线程s会被挂起，等待t线程运行结束才能恢复执行。当t.join()成功返回时，s线程就知道t线程已经结束了。所以根据本条原则，在t线程中对共享变量的修改，对s线程都是可见的。类似的还有Thread.isAlive方法也可以检测到一个线程是否结束。可以猜测，当一个线程结束时，会把自己所有操作的结果都同步到主内存。而任何其它线程当发现这个线程已经执行结束了，就会从主内存中重新刷新最新的变量值。所以结束的线程A对共享变量的修改，对于其它检测了A线程是否结束的线程是可见的。 中断规则一个线程在另一个线程上调用interrupt,Happens-Before被中断线程检测到interrupt被调用。假设两个线程A和B，A先做了一些操作operationA，然后调用B线程的interrupt方法。当B线程感知到自己的中断标识被设置时(通过抛出InterruptedException，或调用interrupted和isInterrupted),operationA中的操作结果对B都是可见的。 终结器规则一个对象的构造函数执行结束Happens-Before它的finalize()方法的开始。“结束”和“开始”表明在时间上，一个对象的构造函数必须在它的finalize()方法调用时执行完。根据这条原则，可以确保在对象的finalize方法执行时，该对象的所有field字段值都是可见的。 传递性规则如果操作A Happens-Before B，B Happens-Before C，那么可以得出操作A Happens-Before C。","tags":[{"name":"Java","slug":"Java","permalink":"http://polyval.github.io/Wiki/tags/Java/"}],"categories":[{"name":"Java","slug":"Java","permalink":"http://polyval.github.io/Wiki/categories/Java/"}]},{"title":"CPU占用过高定位","date":"2018-10-06T16:28:21.000Z","path":"wiki/Java/CPU占用过高定位/","text":"方法1找到CPU占用过高的线程top -p &lt;pid&gt; 输入H查看该进程的所有线程的统计情况，从而找到CPU占用过高的线程； 将线程id转化为16进制就是Java堆栈中对应的nid 查看Java堆栈获取Java堆栈 在线程堆栈中找到nid=上一步nid的线程堆栈 找到对应的线程id 如果该线程正在执行Java代码，说明是该Java代码导致的CPU高 如果线程在执行native code，说明是本地代码导致的CPU高。通过pstack pid获取本地线程堆栈，在本地线程堆栈中找到对应线程，借助本地线程堆栈进行定位。 找不到对应的线程id有两种可能 虚拟机自身代码导致的如堆内存枯竭导致的频繁Full GC，或者虚拟机的bug。此时可以通过本地线程堆栈进行定位。 重新创建了线程来执行方法2多次打印线程堆栈，找到相同的代码段","tags":[{"name":"Java","slug":"Java","permalink":"http://polyval.github.io/Wiki/tags/Java/"}],"categories":[{"name":"Java","slug":"Java","permalink":"http://polyval.github.io/Wiki/categories/Java/"}]},{"title":"操作系统是如何实现虚拟内存的","date":"2018-10-06T16:28:21.000Z","path":"wiki/操作系统/操作系统是如何实现虚拟内存的/","text":"要明白操作系统是如何实现虚拟内存的，首先应该明白操作系统为什么要需要虚拟内存 为什么需要虚拟内存早期的程序中访问的内存地址都是实际的物理内存地址。 程序需要加载在内存上运行，即形成进程。起初，只有一个进程信息可以被加载到内存，需要运行另一个进程时，需要将当前进程的信息先存储到磁盘上，然后从磁盘上读取另一个进程的信息。但是磁盘I/O是很慢的，导致任务切换的效率很低 。因此，人们希望将多个进程可以共同存放在内存上，这就出现了一个问题：如何避免一个进程读取、篡改另一个进程的内存信息，即对进程间实现隔离和保护。 同时，程序在编写时，其访问数据和指令跳转时的目标地址很多是固定的。但是程序在加载在内存时，不可能说每次我们都能够分配固定地址的内存给它。尤其是在我们想运行同一程序的多个实例的时候，由于同一程序使用的物理地址是一样的，一起运行就会有冲突。 另外，程序使用的内存会被物理内存所限制，即程序使用的内存不能超过物理内存。 内存虚拟化就是为了解决这些问题出现的，它将程序给的地址看作是虚拟地址(Virtual Address)，然后通过将虚拟地址转换为实际的物理地址，通过操作系统对这个转化过程的控制，来实现隔离、保护、和易用。 如何实现虚拟内存我们可以把我们为什么需要虚拟内存抽象成虚拟内存要实现的几个目标。 虚拟内存的几个目标 不可见性 即对于程序来说，并不知道内存被虚拟化了，程序认为自己拥有独自的物理内存 高效率 虚拟内存的效率要高,不能让程序运行变得太慢(时间效率),也不能因为实现虚拟内存占用太大空间(空间效率)。为了保证时间效率，需要用到硬件的支持。 保护 操作系统需要保证进程间相互隔离，同时也要将操作系统与进程隔离开来。 实现虚拟内存的关键技术是：地址转化，实现地址转化的硬件称为内存管理单元MMU(Memory Management Unit)。我们先来看看地址转化最初的原型：base and bounds，也叫动态重定位(dynamic relocation)。 动态重定位在动态重定位方法中，每个CPU需要两个寄存器来帮助它实现地址转化：base register 和 bounds register。 程序在编写和编译时，其使用的内存地址从0开始。当程序运行时，如OS打算在32KB处开始载入程序，则OS将base寄存器的值设为32KB。程序的地址转化成：$$实际物理地址 = 虚拟地址 + base$$因此，base寄存器实现了地址转化的作用，而bounds寄存器的作用则是进行保护，限制地址引用的范围。 当进行进程间切换时，需要保存base-bounds寄存器的值，以便恢复进程。这个值保存在进程控制块PCB(process control block)里。 动态重定位的缺点动态重定位的缺点在于它会造成内部碎片(internal fragmentation)，造成内存的浪费。如图所示，由于进程的堆和栈不是很大，其中的内存就被浪费掉了 。 为了解决内部碎片的问题，出现了分段技术。 分段(Segmentation)分段技术的出现是为了解决程序因占用连续的内存空间而产生内部碎片的问题，利用分段解决内部碎片问题的思想很简单：将进程的内存空间按照逻辑进行分段，每段可存放在物理内存的不同位置，在动态重定位一对base-bounds寄存器的基础上，给进程的每段都分配一对base-bounds寄存器。常见分段方式分为三段：代码段、栈和堆。比如说我们要对某个代码段的虚拟地址进行寻址，只需要根据代码段的base-bounds寄存器，按照动态重定位的方式寻址即可。那么，给定一个虚拟地址，如何判断它是属于哪个段的呢？ 如何确定虚拟地址属于哪个段有两种方法进行确定。 将地址前面几位当作段标志比如一个14位的虚拟内存，我们可以将其前两位当做段的标志位，如00表示代码段，01表示堆，11表示栈。 根据虚拟地址如何产生的来判断如果虚拟地址由程序计数器(program count)产生的，则为代码段，如果为栈指针，则为栈段，否则为堆段。 MMU记录的其它信息除了每段的base-bounds寄存器外，MMU还记录了段的其它一些信息。 因为栈是反方向扩张的，因此需要记录内存扩张的方向。Protection用来表示段的属性，可以用来共享一些段。 分段的缺点每个程序都不一样，其各段所占用的内存空间大小也不一样，造成内存的占用情况如下图所示 内存上出现了各种大小的小洞，如果我们需要分配一个新段，比这个新段大小小的内存空间对于我们来说都是没有用的，这就造成了内存的浪费，这种浪费称为外部碎片(external fragmentation)。为了解决这个问题，出现了各种方法，如内存整理(compact)，各种内存管理算法(best fit、first fit)。但是并没有完美的方法解决这个问题。 分页(Paging)分段中引起外部碎片的原因是每段的大小都不一样。分页对内存的处理方式是:将虚拟内存和物理内存分为若干个固定长度的单元，这个单元称为页。 如何寻址每个进程都对应一个页表(page table)，页表存储着虚拟内存页对应的实际物理内存页。虚拟地址需要分为两部分：虚拟页号VPN(virtual page number)和偏移量offset。通过页表可以知道VPN对应的PFN，通过offset进行准确寻址。 页表存放在哪页表占用空间很大。举个例子，假设一个32位的地址空间，每页大小为4KB，则虚拟内存分为20位的VPN和12位的偏移量(10位1KB，4KB则为12位)。20位的VPN表示存在$2^{20}$条转化映射，假设每条映射占用4字节，则一个页表需要占用4M的大小。 由于页表太大，因此将内部存储在内存中。在MMU中的页表基(page-table base)寄存器中存放页表在内存中的起始位置。 分页的缺点因为页表存放在内存上，在对虚拟地址进行转化时，首先需要从内存中的页表读到其对应物理页，相当于多了一次内存的读操作，因此分页会降低速度，同时页表的存储占用过多内存。 给分页加加速要想加加速，就需要硬件来帮个忙。TLB (Translation-Lookaside Buffer)，中文译为快表。TLB是集成在MMU上的缓存，用来存储部分页表记录。 查询页表时，首先去TLB查，查到了称为TLB命中(hit)，如果没查到，称为TLB失败(miss)，此时去内存中的页表查。缓存大小有限，当有新记录放入到TLB，需要进行缓存置换，缓存置换有许多方法，这里不再展开。","tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://polyval.github.io/Wiki/tags/操作系统/"}],"categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://polyval.github.io/Wiki/categories/操作系统/"}]},{"title":"React Virtual DOM","date":"2018-10-06T16:28:21.000Z","path":"wiki/前端/React Vitual DOM/","text":"为什么说操作DOM慢DOM对象本身是一个js对象，其实操作这个对象并不慢，慢的是操作这个对象后，会触发一些浏览器行为，比如布局(layout)和绘制(paint)。 浏览器渲染主要流程浏览器如何工作的 浏览器对HTMl的渲染分为5个步骤： 处理HTML标记并构建出DOM树 处理CSS标记并构建CSSOM树 将两者关联生成Render Tree Layout根据Render Tree来布局，计算每个节点的几何信息 根据计算好的信息绘制整个页面 其中，layout是最耗时的步骤。因此需要最小化layout的次数 什么情况下浏览器会进行layoutlayout用来计算文档中元素的位置和大小，在HTML第一次被加载的时候，会有一次layout，称为reflow/如下操作也会触发reflow 插入、删除、移动、更新DOM 改变页面内容，如输入框的文本 改变CSS样式 改变窗口大小 Vitual DOM更快么Virtual DOM并不比直接操作DOM快，只不过使用Vitual DOM可以减少不必要的DOM更新，从而减少比较耗时的layout和paint工作。","tags":[{"name":"React","slug":"React","permalink":"http://polyval.github.io/Wiki/tags/React/"}],"categories":[{"name":"前端","slug":"前端","permalink":"http://polyval.github.io/Wiki/categories/前端/"}]},{"title":"性能瓶颈","date":"2018-10-06T16:28:21.000Z","path":"wiki/Java/性能瓶颈/","text":"一个好的程序，应该是能够充分利用CPU。如果一个程序在单CPU的机器上无论在多大的压力下都无法令CPU的使用率接近100% ,说明这个程序设计地有问题。 常见的性能瓶颈不恰当的同步导致的资源占用 锁加得不恰当 锁粒度过大 不恰当的线程模型 效率低下的SQL或者不恰当的数据库设计不恰当的GC参数线程数量不足内存泄露导致的频繁GC通过线程堆栈识别性能瓶颈典型的堆栈特征 绝大多数线程的堆栈表现在同一个调用上下文上，且只剩下非常少的空闲线程 绝大多数线程处于等待状态，只有几个工作的线程，总体性能上不去。可能的原因是，系统存在关键路径，在该关键路径上没有足够的能力给下个阶段输送大量的任务，导致其 它地方空闲。如在消息分发系统，消息分发一般是一个线程，而消息处理是多个线程，这 时候消息分发是瓶颈的话，那么从线程堆栈就会观察到上面提到的现象:即该关键路径 没有足够的能力给下个阶段输送大量的任务，导致其它地方空闲 线程总的数量很少。这个一般与线程池的设计有关。","tags":[{"name":"Java","slug":"Java","permalink":"http://polyval.github.io/Wiki/tags/Java/"}],"categories":[{"name":"Java","slug":"Java","permalink":"http://polyval.github.io/Wiki/categories/Java/"}]},{"title":"","date":"2018-10-02T13:31:18.736Z","path":"wiki/Java/Btrace-生产环境调试/","text":"Btrace可以做什么Btace可以动态的，在不需要重启的情况下监控系统运行情况，方便的获取程序运行时的数据信息。 获取参数值、返回值 查看堆栈信息 分析方法的耗时情况","tags":[],"categories":[{"name":"Java","slug":"Java","permalink":"http://polyval.github.io/Wiki/categories/Java/"}]},{"title":"","date":"2018-05-13T13:38:03.543Z","path":"wiki/psychology/面质(confrontation)/","text":"面质(confrontation) 指出来访者身上存在的矛盾、不一致性。 常见的矛盾有 语言的不一致 你说没事，但是你又说他让你觉得烦 语言和行为的不一致 你说你想取得好成绩，但是你却把大多数时间花在睡觉和看电视剧上。 行为的不一致 你虽然在笑，但是你却紧咬着牙关 感受的不一致 你妹妹让你很生气，但是你也有点高兴，因为现在别人终于知道她是什么样的人了 价值观与行为的不一致 你说你尊重别人的选择，但是你却想去说服他们选择堕胎是错的 价值观与感觉的不一致 你觉得应该多多联系保持关系，但是你却对这种联系感到很不习惯 自我认知与实际经历的不一致 你说没人喜欢你，但是你之前不是说有人给你写过情书么 理想和现实自我的不一致 你想达到你妈的高要求，但是你感觉其实自己很普通 双方意见的不一致 你说你还不够努力，但是我觉得你已经做得很好了","tags":[],"categories":[{"name":"psychology","slug":"psychology","permalink":"http://polyval.github.io/Wiki/categories/psychology/"}]},{"title":"","date":"2018-04-21T11:19:07.435Z","path":"wiki/高质量代码/","text":"使用boolean值来给程序做注释相信大家看到一个if语句有很多条件的时候都会特别头痛，因为很难理解。例如下面的例子： 123if ( ( elementIndex &lt; 0 ) || ( MAX_ELEMENTS &lt; elementIndex ) || elementIndex == lastElementIndex) &#123; do....&#125; 但如果换成下面的写法，用boolean值的名字来给if语句注释，看起来就很好理解了。 12345finished = ( ( elementIndex &lt; 0 ) || ( MAX_ELEMENTS &lt; elementIndex ) );repeatedEntry = ( elementIndex == lastElementIndex );if ( finished || repeatedEntry ) &#123;...&#125;","tags":[],"categories":[]},{"title":"","date":"2018-04-20T07:52:29.682Z","path":"wiki/程序员的自我修养/","text":"编译过程一般分为几步 词法分析 扫描器扫描源代码，利用有限状态机将源代码的字符序列分割成一系列的记号，记号包括关键字、符号、字符串等 语法分析 对记号进行语法分析，产生以表达式为节点的语法树 语义分析 对语法树的表达式加上类型，语法合法不代表这个语句是有意义的，比如两个指针做乘法运算是没有意义的 源代码优化 代码生成 转换为目标机器码 目标代码优化 链接的作用链接的主要内容就是把各个模块之间相互引用的部分处理好，使得各个模块之间能够正确地衔接 链接过程的主要步骤 地址和空间分配(Address and Storage Allocation) 符号解析(Symbol Resolution) 重地位(Relocation) 编译后的目标文件(Object File)存储着什么信息文件头，代码段，数据段等信息，程序的指令和数据是分开存放的","tags":[],"categories":[]},{"title":"亲密关系中的沟通","date":"2018-04-20T02:28:21.000Z","path":"wiki/psychology/亲密关系中的沟通/","text":"这里指的聊天对象是指你关心的恋人、朋友以及想要成为朋友的人，聊天目标是更加了解对方。 在聊天过程中，作为参与者的你主要做两件事：输入信息(你接收别人产生的信息)和输出信息(你产生信息)。 信息的分类信息主要分为语言信息和非语言信息。对于语言信息，可以大致分为如下四类 客观事实 即不包括主观思考、推理的信息，主要是我们听到、看到或经历的事情，这类信息是交流中比例最大的信息 思想 即我们对事情的看法，包括我们的信念、价值观、观点等。 感受 需要 我们的欲望、需要、希望，我们的目标和理想，我们对未来的期盼，这些都是需要 如何输入信息如何输入语言信息输入语言信息即倾听对方 倾听的目的 理解他人 欣赏他人 从别人身上学习某些东西 帮助或者安慰别人 倾听的禁忌 不要和对方比较 不要跟别人比谁更惨、谁的经历更丰富。 听的时候不要想着接下来要说什么 不要总是把话题引到自己身上 别人说的事情会让你联想到自己的经历，等别人说完了再说自己经历、感受过的事情。 有效倾听在倾听时，为了让他人感觉到我们在积极的倾听并更加准确的理解对方，还需要重述、澄清和反馈这三个部分。 重述重述即你说出你对别人说的话的理解，如果你想着要去重述，自然你就会更加积极的去理解对方，同时，也可以让对方纠正你理解不当的地方，从而更加准确的理解对方。 一些基本的重述句型是这样的。 所以你觉得(感觉)…. 你的意思是…. 也就是说…. 你听起来很(伤心、愤怒、难过等)…. 在输出部分，我们会详细讲述重述 澄清澄清即不断的提问题来得到更准确的信息。去了解更多的细节、背景等。 反馈反馈即告诉对方其谈话对你的效果和影响，及你的想法和感受。如： 我觉得你有些事情没告诉我 听你说完这个，我觉得…. 如何输入非语言信息注意对方的表情、眼神、身体姿态。 如何输出信息如何输出语言信息问问题问题应该关注什么问问题时关注对方的四个方面:经历事实等，感觉，想法，欲求。尤其注重感觉和想法。 从时间点上来说： 过去(过去的经历、记忆和感受) 现在 未来(期望，愿望) 这些宏观上的大分类，可以让我们在不知道问什么时进行一个指导。比如说当对方说了其假期出去旅游的一个事实时，通过四个方面大分类的指导，你可以借由这个事实去问对方的感觉(出去玩了几天感觉怎么样)、想法(这个城市有什么特点，你觉得这个城市怎么样)、欲求(你以后想去什么样的地方旅游，什么样的地方吸引你)，也可以借由时间点的分类，过去(你原来还去过哪些地方)、未来(未来还想去什么地方)。当然，最佳的方式是两种分类进行结合，即过去的(经历、感觉、想法和欲求)，未来的(经历、感觉、想法和欲求)。 开放式问题的两种重要结构 从小话题往更大的话题问 这种结构适合当前小话题难以继续下去的情况 我有时候会画画 除了画画平时空闲的时候还做些什么(经历事实等，更大的话题是业余活动) 从大话题往更小的话题问 这种结构适合更加深入的了解对方，对某个话题进行深入的沟通 我有时候会画画 你一般会画些什么或画画的时候是什么心态(感觉) 探索性问题 扩展性探索 让别人说出更多跟刚才话题相关的事情 你其他室友有没有类似有趣的事情？ 让别人举个与刚才相关的例子 澄清 重述 对重要的信息进行重述 有时候可以直接以疑问的语气重复关键字，让对方继续说下去 情感反映。指出对方的感觉 你觉得__因为_ 也许你感到___ 你听起来很___ 自我袒露在问问题时，我们关注的是对方，在自我袒露时，我们是通过表达来让对方了解自己，同样，我们可以通过问问题关注的几个大方向来指导我们自己进行自我袒露。自我袒露有几个需要注意的地方。 在自我袒露后，要及时把关注点放在对方身上。 不要混淆信息 即不要将经历事实等，感觉，想法，欲求等混淆在一句话说。如“你就不能表现得有人情味点”就是将想法和需要混淆在一起。正确的表达顺序应该是观察，想法，感受，需要。 如何输出非语言信息 眼神接触 不要一直盯着别人看 点头 身体前倾 语气语调与对方相匹配 如何持续聊天在聊天时，主要以话题为单位，一次聊天实际上就是由一个个话题组成。 话题的深入当对方说起某个事情时，我们可以通过开放式问题来引导对方说出与这个事情有关的感觉、想法和欲求等，包括过去、现在和未来这三个时间点。对方在说出其感觉、想法和需要时，我们应利用重述、澄清和反馈来实现有效倾听。同时，探索性问题也可以引导对方更深入的探索。在某些时候，我们可以进行自我袒露，自我袒露可以帮助对方更好的自我袒露。 话题的切换如果某个话题聊得差不多了或者没有进一步探索的价值，我们需要进行话题的切换。利用开放式问题的两种结构，可以从小话题切换到大话题，也可以从大话题切换到小话题，同时，利用扩展性探索，可以实现话题的扩展。从之前聊天内容中寻找出现过的关键字，可以从一个话题切换到另一个话题。","tags":[{"name":"心理学","slug":"心理学","permalink":"http://polyval.github.io/Wiki/tags/心理学/"}],"categories":[{"name":"psychology","slug":"psychology","permalink":"http://polyval.github.io/Wiki/categories/psychology/"}]},{"title":"什么是微服务","date":"2018-04-19T16:28:21.000Z","path":"wiki/微服务/什么是微服务/","text":"什么是微服务微服务，又称微服务架构。是一种新兴的软件架构模式。微服务架构模式通过将多种细小的服务进行整合来形成软件，这些服务运行在自己独立的进程上，服务之间通过轻量级机制(常用的是HTTP API)进行通讯。 微服务架构与传统架构的区别传统软件架构模式是一体化架构(Monolithic Architecture)，一体化架构是指软件最终以一个整体的形态呈现出来，是一个单一的可执行程序，改变其中任何一个部分都需要重新生成和部署这个软件。而在微服务架构，服务就是一个运行的程序，运行在独立的进程上，如果你改变了某个服务涉及的代码，只需要重新部署这个服务即可。 微服务的优点 易于扩展 一体化应用进行扩展时需要针对整个应用进行扩展 ，而微服务架构可以根据服务进行扩展 便于持续交付 改变其中某个部分只需要重新生成和部署对应的服务 服务可重用 容错性更强 通过功能分散，使得应用不会轻易因为一个错误而崩溃 微服务的缺点 远程调用会有更多的延时 测试更麻烦","tags":[{"name":"微服务","slug":"微服务","permalink":"http://polyval.github.io/Wiki/tags/微服务/"}],"categories":[{"name":"微服务","slug":"微服务","permalink":"http://polyval.github.io/Wiki/categories/微服务/"}]},{"title":"云计算","date":"2017-02-19T16:28:21.000Z","path":"wiki/云计算/云计算/","text":"什么是云计算云计算是通过网络以自助服务的方式获得所需要的IT资源的模式。 获取路径：通过网络 获取方式：自助服务 获取对象：IT资源(如计算能力、存储能力、带宽等) 横向伸缩通过增加或减少相同IT资源个数来实现伸缩 纵向伸缩通过用具有更高或者更低资源能力的IT资源进行替换来实现伸缩 云计算的三种服务模式 IaaS：基础设施服务，Infrastructure-as-a-service PaaS：平台服务，Platform-as-a-service SaaS：软件服务，Software-as-a-service","tags":[{"name":"云计算","slug":"云计算","permalink":"http://polyval.github.io/Wiki/tags/云计算/"}],"categories":[{"name":"云计算","slug":"云计算","permalink":"http://polyval.github.io/Wiki/categories/云计算/"}]}]}